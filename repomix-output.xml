This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
ai_color_recommender.py
color_adjuster.py
color_generator.py
config_manager.py
custom_harmony.py
file_handler.py
icon.ico
image_recolorer.py
language_manager.py
main.py
palette_sharing.py
preset_browser.py
preset_generator.py
README.md
RELEASE_NOTES_v1.0.1.md
version/ColorPaletteGenerator v1.0.1.zip
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="color_adjuster.py">
"""Color adjustment utilities (no UI).

All Tkinter UI for color adjustment dialogs lives in main.py.
"""

from __future__ import annotations

RGB = tuple[int, int, int]


def apply_warmth(rgb: RGB, warmth: float) -> RGB:
    """Apply warmth/coolness to a color.

    warmth > 0 shifts toward red/yellow, warmth < 0 shifts toward blue.
    """
    r, g, b = rgb
    if warmth > 0:
        r = min(255, int(r + warmth * 2))
        g = min(255, int(g + warmth * 0.5))
        b = max(0, int(b - warmth * 0.5))
    else:
        r = max(0, int(r + warmth * 0.5))
        g = max(0, int(g + warmth * 0.5))
        b = min(255, int(b - warmth * 2))
    return (r, g, b)


def apply_contrast(rgb: RGB, contrast: float) -> RGB:
    """Apply contrast adjustment around mid-gray (128)."""
    r, g, b = rgb
    r = int(128 + (r - 128) * (1 + contrast))
    g = int(128 + (g - 128) * (1 + contrast))
    b = int(128 + (b - 128) * (1 + contrast))
    r = max(0, min(255, r))
    g = max(0, min(255, g))
    b = max(0, min(255, b))
    return (r, g, b)
</file>

<file path="config_manager.py">
"""
Configuration Manager Module
Manages application settings using encrypted DAT files in data/ folder
"""

import logging


class ConfigManager:
    """Application configuration manager using file_handler for encrypted storage"""
    
    DEFAULT_CONFIG = {
        'auto_save_enabled': True,
        'auto_save_interval': 300,
        'kmeans_max_colors': 5,
        'kmeans_filter_background': True,
        'kmeans_max_iterations': 12,
        'window_width': 700,
        'window_height': 520,
        'theme': 'light',  # 'light' or 'dark'
        'language': 'ko',  # 'ko' or 'en'
        'background_luminance_high': 240,
        'background_luminance_low': 15,
        'saturation_threshold': 0.15,
        'max_recent_files': 10,
        'default_export_format': 'png',
        'screen_picker_size': 100,

        # Recent colors
        'recent_colors': [],
        'max_recent_colors': 50
    }
    
    def __init__(self, file_handler):
        """Initialize with file_handler for encryption"""
        self.file_handler = file_handler
        self.config = self.load_config()
    
    def load_config(self):
        """Load configuration from data/config.dat"""
        self.config = self.file_handler.load_data_file('config.dat', default=self.DEFAULT_CONFIG.copy())
        return self.config

    def save_config(self):
        """Save configuration to data/config.dat"""
        try:
            self.file_handler.save_data_file('config.dat', self.config)
            logging.info("Config saved successfully")
            return True
        except Exception as e:
            logging.error(f"Config save error: {e}")
            return False
    
    def get(self, key, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def set(self, key, value):
        """Set configuration value"""
        self.config[key] = value
    
    def reset_to_defaults(self):
        """Reset to default configuration"""
        self.config = self.DEFAULT_CONFIG.copy()
        self.save_config()
        logging.info("Config reset to defaults")
</file>

<file path="palette_sharing.py">
"""
Palette Sharing Module
Simple file-based palette sharing with export/import functionality
"""

import json
import os
import datetime
from typing import Any


class PaletteSharingManager:
    """Manage palette export and import for sharing"""

    def export_palette(self, palette_data: dict[str, Any], filename: str) -> str:
        """
        Export a palette to a shareable JSON file.
        
        Args:
            palette_data: Dictionary with 'name', 'colors', 'timestamp'
            filename: Path to write.
        """
        if not filename:
            raise ValueError('filename is required')

        if 'colors' not in palette_data or not isinstance(palette_data['colors'], list):
            raise ValueError('palette_data.colors must be a list')

        export_data = {
            'format_version': '1.0',
            'palette': {
                'name': palette_data.get('name', 'Unnamed Palette'),
                'colors': palette_data['colors'],
                'timestamp': palette_data.get('timestamp', datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')),
                'author': os.getlogin(),
                'color_count': len(palette_data['colors']),
            },
        }

        directory = os.path.dirname(filename)
        if directory and not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)

        return filename
    
    def import_palette(self, filename: str) -> dict[str, Any]:
        """
        Import a palette from a shareable file.
        
        Returns:
            Dictionary with palette data or None if failed
        """
        if not filename:
            raise ValueError('filename is required')

        with open(filename, 'r', encoding='utf-8') as f:
            import_data = json.load(f)

        if 'palette' not in import_data:
            raise ValueError('Invalid palette file format')

        palette = import_data['palette']
        if 'colors' not in palette or not isinstance(palette['colors'], list):
            raise ValueError('Palette has no valid colors list')

        return {
            'name': palette.get('name', 'Imported Palette'),
            'colors': palette['colors'],
            'timestamp': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'source': f"Imported from {os.path.basename(filename)}",
            'original_author': palette.get('author', 'Unknown'),
        }
    
    def export_multiple_palettes(self, palettes_list: list[dict[str, Any]], filename: str) -> str:
        """
        Export multiple palettes to a single collection file
        
        Args:
            palettes_list: List of palette dictionaries
        """
        if not palettes_list:
            raise ValueError('palettes_list is empty')
        if not filename:
            raise ValueError('filename is required')

        export_data = {
            'format_version': '1.0',
            'collection': {
                'name': 'Palette Collection',
                'author': os.getlogin(),
                'export_date': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'palette_count': len(palettes_list),
                'palettes': [],
            },
        }

        for palette in palettes_list:
            export_data['collection']['palettes'].append({
                'name': palette.get('name', 'Unnamed'),
                'colors': palette['colors'],
                'timestamp': palette.get('timestamp', ''),
            })

        directory = os.path.dirname(filename)
        if directory and not os.path.exists(directory):
            os.makedirs(directory, exist_ok=True)

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)

        return filename
    
    def import_collection(self, filename: str) -> list[dict[str, Any]]:
        """
        Import multiple palettes from a collection file
        
        Returns:
            List of palette dictionaries or None if failed
        """
        if not filename:
            raise ValueError('filename is required')

        with open(filename, 'r', encoding='utf-8') as f:
            import_data = json.load(f)

        if 'collection' not in import_data or 'palettes' not in import_data['collection']:
            raise ValueError('Invalid collection file format')

        palettes = import_data['collection']['palettes']

        result: list[dict[str, Any]] = []
        for palette in palettes:
            if 'colors' in palette and isinstance(palette['colors'], list):
                result.append({
                    'name': palette.get('name', 'Imported Palette'),
                    'colors': palette['colors'],
                    'timestamp': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                })

        return result
</file>

<file path="preset_browser.py">
"""Preset palette domain logic (no UI).

UI is handled in main.py.
"""

from __future__ import annotations

from dataclasses import dataclass

from preset_generator import PresetPaletteGenerator


@dataclass(frozen=True)
class PresetFilter:
    tag: str | None = None
    color_rgb: tuple[int, int, int] | None = None
    min_similarity: float = 95.0


class PresetPaletteService:
    """Load and filter preset palettes without any GUI dependencies."""

    def __init__(self, file_handler, data_filename: str = 'preset_palettes.dat'):
        self.file_handler = file_handler
        self.data_filename = data_filename

    def load_palettes(self):
        return PresetPaletteGenerator.load_palettes(self.file_handler, self.data_filename)

    @staticmethod
    def hex_to_rgb(hex_color: str) -> tuple[int, int, int]:
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))

    @staticmethod
    def color_similarity(rgb1: tuple[int, int, int], rgb2: tuple[int, int, int]) -> float:
        r1, g1, b1 = rgb1
        r2, g2, b2 = rgb2
        distance = ((r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2) ** 0.5
        max_distance = (255 ** 2 * 3) ** 0.5
        return (1 - distance / max_distance) * 100

    @classmethod
    def filter_palettes(cls, palettes: list[dict], preset_filter: PresetFilter) -> list[dict]:
        filtered: list[dict] = []
        for palette in palettes:
            if preset_filter.tag:
                if preset_filter.tag not in palette.get('tags', []):
                    continue

            if preset_filter.color_rgb:
                found_similar = False
                for hex_color in palette.get('colors', []):
                    rgb = cls.hex_to_rgb(hex_color)
                    if cls.color_similarity(preset_filter.color_rgb, rgb) >= preset_filter.min_similarity:
                        found_similar = True
                        break
                if not found_similar:
                    continue

            filtered.append(palette)
        return filtered
</file>

<file path="RELEASE_NOTES_v1.0.1.md">
# Color Palette Generator v1.0.1

**Release Date:** February 12, 2026

## üéØ Overview
Major code refactoring and optimization update. This release improves code quality, security, and UI responsiveness without changing user-facing features.

---

## ‚ú® What's New

### üîß Code Optimization
- **Merged icon modules**: Combined `embedded_icon.py` and `embedded_icons.py` into a single module for cleaner imports
- **Simplified main module**: Removed old tkinter-based `main.py`, renamed `main_ctk.py` ‚Üí `main.py`
- **Removed duplicate code**: Eliminated ~32 duplicate dictionary keys in language manager
- **Cleaned unused code**: Removed unused methods (`get_luminance`, `_cleanup_stale_tooltips`) and imports
- **Fixed syntax errors**: Corrected double-comma syntax error in language_manager.py

### üîí Security Improvements
- **External encryption key**: Moved embedded Fernet encryption key to external `secret.key` file
- **Regenerated encryption key**: All data files re-encrypted with new secure key
- **Improved key management**: FileHandler now loads key from file instead of hardcoded value
- **Updated .gitignore**: Added `secret.key`, `embedded_icons.py`, and `assets/` to .gitignore

### üêõ Bug Fixes
- **Fixed empty palette flicker**: New palette with 0 colors no longer flickers when adding first color
- **Fixed scrollbar color mismatch**: Color settings sidebar scrollbar now gray (was blue)
- **Fixed Korean text corruption**: Resolved `ÌïúÍµ≠Ïñ¥` display issue in language settings
- **Fixed import warning**: Resolved Pylance `reportMissingImports` warning for `google.generativeai`

### üìù Documentation
- **English comments**: Converted all Korean comments and docstrings to English across 6 files
- **Improved code readability**: Clearer function documentation and inline comments

---

## üõ†Ô∏è Technical Changes

### Modified Files
- `main.py` (renamed from main_ctk.py): Modern CustomTkinter UI (4593 lines)
- `file_handler.py`: External key loading, removed hardcoded EMBEDDED_KEY
- `embedded_icons.py`: Merged with embedded_icon.py (now includes ICO + PNG icons)
- `ai_color_recommender.py`: Fixed import, English comments
- `color_generator.py`: English comments, removed empty __init__
- `custom_harmony.py`: English comments
- `preset_generator.py`: English comments
- `language_manager.py`: Fixed duplicates, English section headers
- `.gitignore`: Added security and resource files

### Deleted Files
- `main_ctk.py` (renamed to main.py)
- `embedded_icon.py` (merged into embedded_icons.py)
- Old `main.py` (5232-line tkinter version)

### New Files
- `secret.key`: External Fernet encryption key (gitignored)

### Re-encrypted Data
- `data/config.dat`
- `data/custom_harmonies.dat`
- `data/palette_metadata.dat`
- `data/preset_palettes.dat`

---

## üì¶ Installation & Upgrade

### New Installation
1. Download `ColorPaletteGenerator.exe` from Releases
2. Run the executable - no installation required
3. First launch will create `data/` folder and `secret.key`

### Upgrading from v1.0.0
‚ö†Ô∏è **IMPORTANT**: This version uses a new encryption key. Your existing settings and palettes will NOT be migrated automatically.

**To preserve your data:**
1. Export your palettes before upgrading (File ‚Üí Export)
2. Note your settings
3. Install v1.0.1
4. Re-import palettes (File ‚Üí Import)
5. Re-configure settings

Alternatively, continue using v1.0.0 if you have critical data that cannot be exported.

---

## üîç Performance

- **Startup time**: No change
- **UI responsiveness**: Improved (no flicker on empty palette)
- **Memory usage**: Slightly reduced (removed duplicate code)
- **Build size**: ~2% smaller (code optimization)

---

## üåê Compatibility

- **OS**: Windows 10/11 (x64)
- **Python**: 3.10+ (source code)
- **Dependencies**: No changes from v1.0.0

---

## üêú Known Issues

- Palette sharing module (`palette_sharing.py`) currently unused - will be activated in future release
- Preset browser service (`preset_browser.py`) unused - may be deprecated

---

## üìù Changelog Summary

**Added:**
- External encryption key system
- English documentation across codebase

**Fixed:**
- Empty palette flicker bug
- Scrollbar color inconsistency
- Korean text encoding in settings
- Pylance import warnings
- Syntax error in language_manager.py

**Changed:**
- File structure (merged icon modules, renamed main.py)
- Encryption key (new secure key in external file)
- Code organization (removed duplicates, unused code)

**Removed:**
- Old tkinter UI (main.py)
- Embedded encryption key (now external)
- Duplicate code and unused methods
- 32 duplicate dictionary keys

---

## üôè Credits

**Developed by:** jiwonjae-svg

**Tools:**
- CustomTkinter (modern UI framework)
- Pillow (image processing)
- cryptography (Fernet encryption)
- google-generativeai (AI palette generation)

---

## üìÑ License

This software is provided as-is for personal and educational use.

---

## üîó Links

- **GitHub Repository**: https://github.com/jiwonjae-svg/color_palette
- **Issue Tracker**: https://github.com/jiwonjae-svg/color_palette/issues
- **Previous Release (v1.0.0)**: https://github.com/jiwonjae-svg/color_palette/releases/tag/v1.0.0

---

**Full Diff:** [v1.0.0...v1.0.1](https://github.com/jiwonjae-svg/color_palette/compare/v1.0.0...v1.0.1)
</file>

<file path="ai_color_recommender.py">
"""
AI Color Recommendation Module
Generate color palettes using Google Gemini API
"""

import os
import json
import re
from typing import List, Tuple, Optional

try:
    import google.generativeai as genai  # type: ignore[import-untyped]
    GENAI_AVAILABLE = True
except ImportError:
    genai = None
    GENAI_AVAILABLE = False

from language_manager import LanguageManager


class AIColorRecommender:
    """AI-based color recommendation class"""
    
    def __init__(self, api_key: Optional[str] = None, lang: Optional[LanguageManager] = None):
        self.api_key = api_key
        self.model = None
        self.lang = lang or LanguageManager('en')
        
        if api_key:
            self.initialize_model()

    def _t(self, key: str, **kwargs) -> str:
        text = self.lang.get(key)
        return text.format(**kwargs) if kwargs else text
    
    def initialize_model(self):
        """Initialize Gemini model"""
        try:
            if not GENAI_AVAILABLE:
                raise ImportError(self._t('ai_recommender_missing_library', install_cmd='pip install google-generativeai'))
            genai.configure(api_key=self.api_key)
            self.model = genai.GenerativeModel('gemini-2.5-flash-lite')
            return True
        except ImportError as e:
            raise e
        except Exception as e:
            raise Exception(self._t('ai_recommender_init_failed', error=str(e)))
    
    def set_api_key(self, api_key: str) -> bool:
        """Set API key"""
        self.api_key = api_key
        try:
            self.initialize_model()
            return True
        except Exception:
            return False
    
    def generate_palettes(self, num_palettes: int = 5, keywords: str = "", num_colors: int = 5) -> List[dict]:
        """
        Generate color palettes using AI
        
        Args:
            num_palettes: Number of palettes to generate
            keywords: Keywords (e.g.: "ocean, calm, blue")
            num_colors: Number of colors per palette
        
        Returns:
            List of palettes (each palette is a {'name': str, 'colors': List[str]} dict)
        """
        if not self.model:
            raise Exception(self._t('ai_recommender_api_key_not_set'))
        
        # Generate prompt (including name)
        if keywords.strip():
            prompt = self._t(
                'ai_recommender_prompt_with_keywords',
                num_palettes=num_palettes,
                num_colors=num_colors,
                keywords=keywords,
            )
        else:
            prompt = self._t(
                'ai_recommender_prompt_without_keywords',
                num_palettes=num_palettes,
                num_colors=num_colors,
            )
        
        try:
            response = self.model.generate_content(prompt)
            text = response.text.strip()
            
            # Parse response
            palettes = self._parse_response(text, num_colors)
            return palettes[:num_palettes]  # Return up to the requested count
            
        except Exception as e:
            raise Exception(self._t('ai_recommender_generation_failed', error=str(e)))
    
    def _parse_response(self, text: str, expected_colors: int) -> List[dict]:
        """Parse AI response - extract palette names and colors"""
        palettes = []
        
        # HEX color code pattern
        hex_pattern = r'#[0-9A-Fa-f]{6}'
        
        # Process line by line
        lines = text.split('\n')
        for line in lines:
            # Parse "PaletteName: #HEX,#HEX,..." format
            if ':' in line:
                parts = line.split(':', 1)
                name = parts[0].strip()
                colors = re.findall(hex_pattern, parts[1])
                
                if colors and len(colors) >= expected_colors and name:
                    # Normalize to uppercase
                    colors = [c.upper() for c in colors[:expected_colors]]
                    palettes.append({
                        'name': name,
                        'colors': colors
                    })
            else:
                # Colors only without name (backward compatibility)
                colors = re.findall(hex_pattern, line)
                if colors and len(colors) >= expected_colors:
                    # Normalize to uppercase
                    colors = [c.upper() for c in colors[:expected_colors]]
                    palettes.append({
                        'name': self.lang.get('palette_numbered').format(i=len(palettes) + 1),
                        'colors': colors
                    })
        
        return palettes
    
    def test_api_key(self) -> Tuple[bool, str]:
        """Test API key"""
        if not self.api_key:
            return False, self._t('ai_recommender_api_key_not_set')
        
        try:
            self.initialize_model()
            # Simple test request
            response = self.model.generate_content(self._t('ai_recommender_test_prompt'))
            if response and response.text:
                return True, self._t('ai_recommender_test_success')
            else:
                return False, self._t('ai_recommender_test_no_response')
        except Exception as e:
            return False, self._t('ai_recommender_test_failed', error=str(e))


class AISettings:
    """AI settings management"""
    
    @classmethod
    def save_settings(cls, file_handler, api_key: str, num_colors: int = 5, keywords: str = "") -> bool:
        """Save settings (using FileHandler)"""
        try:
            data = {
                'api_key': api_key,
                'num_colors': num_colors,
                'keywords': keywords
            }
            return file_handler.save_data_file('ai_config.dat', data)
        except Exception:
            return False
    
    @classmethod
    def load_settings(cls, file_handler) -> dict:
        """Load settings (using FileHandler)"""
        return file_handler.load_data_file('ai_config.dat', default={
            'api_key': '',
            'num_colors': 5,
            'keywords': ''
        })
</file>

<file path="color_generator.py">
"""
Color Palette Generator Module
Handles color palette generation and harmony calculations
"""

from PIL import Image
import colorsys
from collections import Counter
import random
import logging


class ColorPaletteGenerator:
    """Color palette generator class"""
    
    def extract_main_colors(self, image_path, num_colors=5, filter_background=True):
        """Extract main colors from image using improved K-means clustering"""
        img = Image.open(image_path)
        img = img.convert('RGB')
        img = img.resize((150, 150))

        pixels = list(img.getdata())
        
        if filter_background:
            filtered_pixels = []
            for p in pixels:
                r, g, b = p
                lum = 0.299 * r + 0.587 * g + 0.114 * b
                max_c = max(r, g, b)
                min_c = min(r, g, b)
                sat = 0 if max_c == 0 else (max_c - min_c) / max_c
                
                if not (lum > 240 or lum < 15 or sat < 0.15):
                    filtered_pixels.append(p)
            
            pixels = filtered_pixels if len(filtered_pixels) > 100 else pixels
        
        unique_colors = set(pixels)
        unique_count = len(unique_colors)

        if unique_count <= num_colors:
            pixel_count = Counter(pixels)
            main_colors = [c for c, _ in pixel_count.most_common(num_colors)]
            return main_colors[:num_colors]

        # Prepare data for k-means: sample if too many pixels
        data = pixels
        max_samples = 2000
        if len(data) > max_samples:
            data = random.sample(data, max_samples)

        # initialize centroids by sampling distinct points
        centroids = []
        # ensure we don't sample duplicate initial centroids
        tries = 0
        while len(centroids) < num_colors and tries < num_colors * 10:
            c = tuple(random.choice(data))
            if c not in centroids:
                centroids.append([float(c[0]), float(c[1]), float(c[2])])
            tries += 1

        # fallback if not enough distinct points
        while len(centroids) < num_colors:
            centroids.append([random.randint(0,255), random.randint(0,255), random.randint(0,255)])

        # K-means iterations (Euclidean in RGB)
        max_iter = 12
        for _ in range(max_iter):
            clusters = [[] for _ in range(len(centroids))]
            for p in data:
                # find nearest centroid
                best_i = 0
                best_d = None
                for i, c in enumerate(centroids):
                    dx = c[0] - p[0]
                    dy = c[1] - p[1]
                    dz = c[2] - p[2]
                    d = dx*dx + dy*dy + dz*dz
                    if best_d is None or d < best_d:
                        best_d = d
                        best_i = i
                clusters[best_i].append(p)

            moved = False
            # recompute centroids
            for i, pts in enumerate(clusters):
                if not pts:
                    # reinitialize empty centroid
                    centroids[i] = [float(x) for x in random.choice(data)]
                    moved = True
                    continue
                sx = sum(p[0] for p in pts) / len(pts)
                sy = sum(p[1] for p in pts) / len(pts)
                sz = sum(p[2] for p in pts) / len(pts)
                if (abs(centroids[i][0] - sx) > 0.5 or
                        abs(centroids[i][1] - sy) > 0.5 or
                        abs(centroids[i][2] - sz) > 0.5):
                    moved = True
                centroids[i][0] = sx
                centroids[i][1] = sy
                centroids[i][2] = sz

            if not moved:
                break

        # After convergence, count assignment over full pixel set to get dominant clusters
        full_clusters = [[] for _ in range(len(centroids))]
        for p in pixels:
            best_i = 0
            best_d = None
            for i, c in enumerate(centroids):
                dx = c[0] - p[0]
                dy = c[1] - p[1]
                dz = c[2] - p[2]
                d = dx*dx + dy*dy + dz*dz
                if best_d is None or d < best_d:
                    best_d = d
                    best_i = i
            full_clusters[best_i].append(p)

        # compute final centroids as integer RGB and sort by cluster size
        results = []
        for pts in full_clusters:
            if pts:
                sx = int(sum(p[0] for p in pts) / len(pts))
                sy = int(sum(p[1] for p in pts) / len(pts))
                sz = int(sum(p[2] for p in pts) / len(pts))
                results.append(((sx, sy, sz), len(pts)))

        if not results:
            # fallback
            pixel_count = Counter(pixels)
            return [c for c, _ in pixel_count.most_common(num_colors)][:num_colors]

        # sort by size desc and return top num_colors
        results.sort(key=lambda x: x[1], reverse=True)
        colors = [c for c, _ in results][:num_colors]
        return colors

    def approximate_color_count(self, image_path, sample_size=None):
        """Calculate the approximate number of colors in an image."""
        img = Image.open(image_path)
        img = img.convert('RGB')
        img = img.resize((100, 100))
        pixels = list(img.getdata())
        if sample_size and len(pixels) > sample_size:
            pixels = random.sample(pixels, sample_size)
        return len(set(pixels))

    def hex_to_rgb(self, hex_code):
        """Convert HEX to RGB"""
        hex_code = hex_code.lstrip('#')
        if len(hex_code) == 3:
            hex_code = ''.join([c*2 for c in hex_code])
        return tuple(int(hex_code[i:i+2], 16) for i in (0, 2, 4))
    
    def rgb_to_hex(self, rgb):
        """Convert RGB to HEX"""
        if isinstance(rgb, tuple) or isinstance(rgb, list):
            return '#{:02x}{:02x}{:02x}'.format(int(rgb[0]), int(rgb[1]), int(rgb[2]))
        return '#000000'
    
    def rgb_to_hsv(self, r, g, b):
        """Convert RGB to HSV (with error handling)"""
        try:
            r = max(0, min(255, int(r)))
            g = max(0, min(255, int(g)))
            b = max(0, min(255, int(b)))
            return colorsys.rgb_to_hsv(r/255, g/255, b/255)
        except (ValueError, TypeError) as e:
            logging.warning(f"RGB to HSV conversion error: {e}")
            return 0.0, 0.0, 0.0
    
    def hsv_to_rgb(self, h, s, v):
        """Convert HSV to RGB (with bounds checking)"""
        try:
            h = h % 1.0
            s = max(0.0, min(1.0, s))
            v = max(0.0, min(1.0, v))
            rgb = colorsys.hsv_to_rgb(h, s, v)
            return tuple(max(0, min(255, int(x * 255))) for x in rgb)
        except (ValueError, TypeError) as e:
            logging.warning(f"HSV to RGB conversion error: {e}")
            return (0, 0, 0)
    
    def generate_complementary(self, rgb):
        """Generate complementary color"""
        h, s, v = self.rgb_to_hsv(*rgb)
        comp_h = (h + 0.5) % 1.0
        return self.hsv_to_rgb(comp_h, s, v)
    
    def generate_analogous(self, rgb, angle=30):
        """Generate analogous colors (angle-based)"""
        h, s, v = self.rgb_to_hsv(*rgb)
        analogous_colors = []
        
        for offset in [-angle/360, angle/360]:
            new_h = (h + offset) % 1.0
            analogous_colors.append(self.hsv_to_rgb(new_h, s, v))
        
        return analogous_colors
    
    def generate_triadic(self, rgb):
        """Generate triadic harmony colors"""
        h, s, v = self.rgb_to_hsv(*rgb)
        triadic_colors = []
        
        for offset in [1/3, 2/3]:
            new_h = (h + offset) % 1.0
            triadic_colors.append(self.hsv_to_rgb(new_h, s, v))
        
        return triadic_colors
    
    def generate_monochromatic(self, rgb, count=4):
        """Generate monochromatic harmony palette (brightness/saturation variation)"""
        h, s, v = self.rgb_to_hsv(*rgb)
        mono_colors = []
        
        for i in range(1, count + 1):
            new_v = max(0.0, min(1.0, v * (0.3 + 0.7 * i / count)))
            new_s = max(0.0, min(1.0, s * (0.5 + 0.5 * i / count)))
            mono_colors.append(self.hsv_to_rgb(h, new_s, new_v))
        
        return mono_colors

    def generate_split_complementary(self, rgb):
        """Generate split complementary harmony"""
        h, s, v = self.rgb_to_hsv(*rgb)
        colors = []
        for offset in [150/360, 210/360]:
            new_h = (h + offset) % 1.0
            colors.append(self.hsv_to_rgb(new_h, s, v))
        return colors

    def generate_square(self, rgb):
        """Generate square harmony"""
        h, s, v = self.rgb_to_hsv(*rgb)
        colors = []
        for offset in [120/360, 180/360, 240/360]:
            new_h = (h + offset) % 1.0
            colors.append(self.hsv_to_rgb(new_h, s, v))
        return colors

    def generate_tetradic(self, rgb):
        """Generate tetradic harmony"""
        h, s, v = self.rgb_to_hsv(*rgb)
        colors = []
        for offset in [60/360, 180/360, 240/360]:
            new_h = (h + offset) % 1.0
            colors.append(self.hsv_to_rgb(new_h, s, v))
        return colors

    def generate_double_complementary(self, rgb):
        """Generate double complementary"""
        h, s, v = self.rgb_to_hsv(*rgb)
        colors = []
        for offset in [30/360, 180/360, 210/360]:
            new_h = (h + offset) % 1.0
            colors.append(self.hsv_to_rgb(new_h, s, v))
        return colors

    def generate_random_color(self):
        """Generate a random color"""
        return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

    def adjust_brightness(self, rgb, factor):
        """Adjust brightness (-0.5 ~ 0.5)"""
        h, s, v = self.rgb_to_hsv(*rgb)
        new_v = max(0.0, min(1.0, v + factor))
        return self.hsv_to_rgb(h, s, new_v)

    def adjust_saturation(self, rgb, factor):
        """Adjust saturation (-0.5 ~ 0.5)"""
        h, s, v = self.rgb_to_hsv(*rgb)
        new_s = max(0.0, min(1.0, s + factor))
        return self.hsv_to_rgb(h, new_s, v)

    def adjust_hue(self, rgb, degrees):
        """Adjust hue (-180 ~ 180 degrees)"""
        h, s, v = self.rgb_to_hsv(*rgb)
        new_h = (h + degrees / 360.0) % 1.0
        return self.hsv_to_rgb(new_h, s, v)

    def get_color_temperature(self, rgb):
        """Calculate color temperature (warm=1, cool=-1, neutral=0)"""
        r, g, b = rgb
        if r > b + 30:
            return 1  # warm
        elif b > r + 30:
            return -1  # cool
        else:
            return 0  # neutral

    def generate_palette(self, source, source_type='hex'):
        """Generate palette"""
        if source_type == 'hex':
            base_color = self.hex_to_rgb(source)
        else:
            base_color = source

        palette = {
            'base': base_color,
            'complementary': self.generate_complementary(base_color),
            'analogous': self.generate_analogous(base_color),
            'triadic': self.generate_triadic(base_color),
            'monochromatic': self.generate_monochromatic(base_color),
            'split_complementary': self.generate_split_complementary(base_color),
            'square': self.generate_square(base_color),
            'tetradic': self.generate_tetradic(base_color),
            'double_complementary': self.generate_double_complementary(base_color)
        }
        
        return palette
</file>

<file path="custom_harmony.py">
"""
Custom color harmony management module (remake)
Simple system using only HSV sliders and fixed colors
"""

import colorsys


class CustomHarmonyManager:
    """Custom color harmony management class"""
    
    def __init__(self, file_handler):
        self.file_handler = file_handler
        self.harmonies = self.load_harmonies()
    
    def load_harmonies(self):
        """Load saved harmonies (using FileHandler)"""
        return self.file_handler.load_data_file('custom_harmonies.dat', default=[])
    
    def save_harmonies(self):
        """Save harmonies (using FileHandler)"""
        return self.file_handler.save_data_file('custom_harmonies.dat', self.harmonies)
    
    def add_harmony(self, harmony_data):
        """Add new harmony"""
        self.harmonies.append(harmony_data)
        return self.save_harmonies()
    
    def update_harmony(self, index, harmony_data):
        """Update harmony"""
        if 0 <= index < len(self.harmonies):
            self.harmonies[index] = harmony_data
            return self.save_harmonies()
        return False
    
    def delete_harmony(self, index):
        """Delete harmony"""
        if 0 <= index < len(self.harmonies):
            self.harmonies.pop(index)
            return self.save_harmonies()
        return False
    
    def apply_harmony(self, base_color_hex, harmony_index):
        """Generate color list by applying harmony rules"""
        if not (0 <= harmony_index < len(self.harmonies)):
            return []
        
        harmony = self.harmonies[harmony_index]
        colors_data = harmony.get('colors', [])
        
        # HEX to RGB
        base_rgb = self.hex_to_rgb(base_color_hex)
        base_h, base_s, base_v = colorsys.rgb_to_hsv(base_rgb[0]/255, base_rgb[1]/255, base_rgb[2]/255)
        
        colors = []
        for color_data in colors_data:
            color_type = color_data.get('type')
            
            if color_type == 'hsv':
                # Apply HSV slider values
                h_offset = color_data.get('h_offset', 0) / 360  # Convert -180~180 degrees to 0~1
                s_offset = color_data.get('s_offset', 0) / 100  # Convert -100~100% to -1~1
                v_offset = color_data.get('v_offset', 0) / 100  # Convert -100~100% to -1~1
                
                new_h = (base_h + h_offset) % 1.0
                new_s = max(0, min(1, base_s + s_offset))
                new_v = max(0, min(1, base_v + v_offset))
                
                rgb = colorsys.hsv_to_rgb(new_h, new_s, new_v)
                colors.append(self.rgb_to_hex(tuple(int(c * 255) for c in rgb)))
            
            elif color_type == 'fixed':
                # Fixed color
                fixed_color = color_data.get('color', '#FFFFFF')
                colors.append(fixed_color)
        
        return colors
    
    @staticmethod
    def hex_to_rgb(hex_color):
        """Convert HEX to RGB"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    @staticmethod
    def rgb_to_hex(rgb):
        """Convert RGB to HEX"""
        return '#{:02x}{:02x}{:02x}'.format(*rgb)
</file>

<file path="file_handler.py">
"""
File Handler Module
Handles PGF file save/load, encryption, and recent files management
"""

import os
import json
import base64
import logging
import datetime
from cryptography.fernet import Fernet

# Path to external key file
KEY_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'secret.key')


def _load_key():
    """Load Fernet key from external file"""
    try:
        with open(KEY_FILE, 'r', encoding='utf-8') as f:
            key_b64 = f.read().strip()
        return base64.b64decode(key_b64)
    except FileNotFoundError:
        logging.error(f"Key file not found: {KEY_FILE}")
        raise
    except Exception as e:
        logging.error(f"Failed to load key: {e}")
        raise


class FileHandler:
    """File operations with encryption"""
    
    def __init__(self):
        self._fernet_key = _load_key()
        os.makedirs('data', exist_ok=True)
    
    def _encrypt_aes(self, data_string):
        """AES encryption"""
        try:
            fernet = Fernet(self._fernet_key)
            return fernet.encrypt(data_string.encode('utf-8'))
        except Exception as e:
            logging.error(f"Encryption error: {e}")
            raise
    
    def _decrypt_aes(self, encrypted_data):
        """AES decryption"""
        try:
            fernet = Fernet(self._fernet_key)
            return fernet.decrypt(encrypted_data).decode('utf-8')
        except Exception as e:
            logging.error(f"Decryption error: {e}")
            raise
    
    def save_to_file(self, path, workspace_data):
        """Save workspace to encrypted file"""
        try:
            if not path:
                raise ValueError("No save path specified")
            
            directory = os.path.dirname(path)
            if directory and not os.path.exists(directory):
                os.makedirs(directory, exist_ok=True)
            
            data_json = json.dumps(workspace_data, ensure_ascii=False)
            encrypted = self._encrypt_aes(data_json)
            
            temp_path = path + '.tmp'
            try:
                with open(temp_path, 'wb') as f:
                    f.write(encrypted)
                
                if os.path.exists(path):
                    backup_path = path + '.bak'
                    if os.path.exists(backup_path):
                        os.remove(backup_path)
                    os.rename(path, backup_path)
                
                os.rename(temp_path, path)
                
                backup_path = path + '.bak'
                if os.path.exists(backup_path):
                    try:
                        os.remove(backup_path)
                    except Exception:
                        pass
                        
            except Exception as write_error:
                if os.path.exists(temp_path):
                    try:
                        os.remove(temp_path)
                    except Exception:
                        pass
                raise write_error
            
            logging.info(f"Saved workspace: {path}")
            return True
            
        except PermissionError:
            logging.error(f"Save failed: Permission denied for {path}")
            return False
        except OSError as e:
            logging.error(f"Save failed: OS error - {str(e)}")
            return False
        except Exception as e:
            logging.error(f"Save failed: {str(e)}")
            return False
    
    def load_from_file(self, path):
        """Load workspace from encrypted file"""
        try:
            if not os.path.exists(path):
                raise FileNotFoundError(f"File not found: {path}")
            
            with open(path, 'rb') as f:
                file_data = f.read()
            
            try:
                data_json = self._decrypt_aes(file_data)
            except Exception:
                try:
                    data_json = base64.b64decode(file_data).decode('utf-8')
                    logging.info("Loaded old format file (base64)")
                except Exception:
                    raise ValueError("Unrecognized file format")
            
            workspace_data = json.loads(data_json)
            logging.info(f"Loaded workspace: {path}")
            return workspace_data
            
        except FileNotFoundError as e:
            logging.error(str(e))
            return None
        except json.JSONDecodeError:
            logging.error(f"JSON decode error for {path}")
            return None
        except Exception as e:
            logging.error(f"Load failed: {str(e)}")
            return None
    
    def load_recent_files(self):
        """Load recent files list"""
        return self.load_data_file('recent_files.dat', default=[])
    
    def save_recent_files(self, recent_files):
        """Save recent files list"""
        self.save_data_file('recent_files.dat', recent_files)
    
    def add_recent_file(self, file_path, recent_files, max_recent=10):
        """Add file to recent files list"""
        if file_path in recent_files:
            recent_files.remove(file_path)
        recent_files.insert(0, file_path)
        if len(recent_files) > max_recent:
            recent_files = recent_files[:max_recent]
        return recent_files
    
    def save_data_file(self, filename, data, data_dir='data'):
        """Save data to encrypted .dat file"""
        try:
            os.makedirs(data_dir, exist_ok=True)
            
            filepath = os.path.join(data_dir, filename)
            if not filepath.endswith('.dat'):
                filepath += '.dat'
            
            data_json = json.dumps(data, ensure_ascii=False)
            encrypted = self._encrypt_aes(data_json)
            
            with open(filepath, 'wb') as f:
                f.write(encrypted)
            
            logging.info(f"Saved data file: {filepath}")
            return True
        except Exception as e:
            logging.error(f"Save data file error: {e}")
            return False
    
    def load_data_file(self, filename, data_dir='data', default=None):
        """Load data from encrypted .dat file"""
        try:
            filepath = os.path.join(data_dir, filename)
            if not filepath.endswith('.dat'):
                filepath += '.dat'
            
            if not os.path.exists(filepath):
                json_path = filepath.replace('.dat', '.json')
                if os.path.exists(json_path):
                    with open(json_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    self.save_data_file(filename, data, data_dir)
                    logging.info(f"Migrated JSON to DAT: {json_path} -> {filepath}")
                    return data
                return default
            
            with open(filepath, 'rb') as f:
                encrypted_data = f.read()
            
            data_json = self._decrypt_aes(encrypted_data)
            data = json.loads(data_json)
            
            logging.info(f"Loaded data file: {filepath}")
            return data
        except Exception as e:
            logging.error(f"Load data file error: {e}")
            try:
                json_path = os.path.join(data_dir, filename.replace('.dat', '.json'))
                if os.path.exists(json_path):
                    with open(json_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
            except Exception:
                pass
            return default

    def load_palette_metadata(self):
        """Load palette metadata (list of saved palettes with paths and info)"""
        return self.load_data_file('palette_metadata.dat', default=[])
    
    def save_palette_metadata(self, metadata):
        """Save palette metadata"""
        return self.save_data_file('palette_metadata.dat', metadata)
    
    def add_palette_metadata(self, name, colors, file_path):
        """Add palette metadata entry"""
        metadata = self.load_palette_metadata()
        
        # Remove existing entry with same path
        metadata = [m for m in metadata if m.get('path') != file_path]
        
        # Add new entry
        entry = {
            'name': name,
            'colors': colors,
            'path': file_path,
            'timestamp': datetime.datetime.now().isoformat()
        }
        metadata.insert(0, entry)
        
        # Limit to 100 entries
        if len(metadata) > 100:
            metadata = metadata[:100]
        
        return self.save_palette_metadata(metadata)
    
    def remove_palette_metadata(self, file_path):
        """Remove palette metadata entry by file path"""
        metadata = self.load_palette_metadata()
        metadata = [m for m in metadata if m.get('path') != file_path]
        return self.save_palette_metadata(metadata)
    
    def clean_palette_metadata(self):
        """Remove metadata entries for non-existent files"""
        metadata = self.load_palette_metadata()
        cleaned = [m for m in metadata if os.path.exists(m.get('path', ''))]
        if len(cleaned) != len(metadata):
            self.save_palette_metadata(cleaned)
        return cleaned
</file>

<file path="image_recolorer.py">
"""
Image Recoloring Module
Applies palette colors to images based on brightness values
"""

from PIL import Image, ImageTk, ImageFilter
import numpy as np


class ImageRecolorer:
    """Apply palette colors to images based on brightness zones"""
    
    def hex_to_rgb(self, hex_color):
        """Convert HEX to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    def rgb_to_hex(self, rgb):
        """Convert RGB tuple to HEX"""
        return '#{:02x}{:02x}{:02x}'.format(int(rgb[0]), int(rgb[1]), int(rgb[2]))
    
    def get_brightness(self, rgb):
        """Calculate brightness value (0-255) from RGB"""
        # Using perceived brightness formula
        r, g, b = rgb
        return 0.299 * r + 0.587 * g + 0.114 * b
    
    def sort_palette_by_brightness(self, palette_hex_colors):
        """Sort palette colors from brightest to darkest"""
        color_brightness = []
        for hex_color in palette_hex_colors:
            rgb = self.hex_to_rgb(hex_color)
            brightness = self.get_brightness(rgb)
            color_brightness.append((hex_color, brightness))
        
        # Sort by brightness (descending - brightest first)
        color_brightness.sort(key=lambda x: x[1], reverse=True)
        return [color for color, _ in color_brightness]
    
    def apply_palette_to_pil_image(self, img: Image.Image, palette_hex_colors, blur_radius: float = 0.6) -> Image.Image:
        """Apply palette colors to an in-memory PIL image.

        This is used for fast previews (apply to a downscaled image) and for full-size processing.
        """
        alpha = None
        if img.mode in ('RGBA', 'LA'):
            alpha = img.getchannel('A')
        rgb_img = img.convert('RGB')

        gray = np.array(rgb_img.convert('L'))

        sorted_palette = self.sort_palette_by_brightness(palette_hex_colors)
        num_colors = len(sorted_palette)
        if num_colors <= 0:
            return img.copy()

        min_val = gray.min()
        max_val = gray.max()

        denom = float(max_val - min_val) if max_val != min_val else 1.0
        zone_idx = np.floor(((gray.astype(np.float32) - float(min_val)) / denom) * num_colors).astype(np.int32)
        zone_idx = np.clip(zone_idx, 0, num_colors - 1)

        zone_palette = [self.hex_to_rgb(sorted_palette[num_colors - 1 - i]) for i in range(num_colors)]
        zone_palette = np.array(zone_palette, dtype=np.uint8)

        result = zone_palette[zone_idx]
        result_img = Image.fromarray(result.astype('uint8'), 'RGB')

        try:
            if blur_radius and float(blur_radius) > 0:
                result_img = result_img.filter(ImageFilter.GaussianBlur(radius=float(blur_radius)))
        except Exception:
            pass

        if alpha is not None:
            try:
                result_img.putalpha(alpha)
            except Exception:
                pass
        return result_img

    def apply_palette_to_image(self, image_path, palette_hex_colors, blur_radius: float = 0.6):
        """
        Apply palette colors to image based on brightness zones
        
        Args:
            image_path: Path to the image file
            palette_hex_colors: List of hex color strings (e.g., ['#FF0000', '#00FF00', ...])
        
        Returns:
            PIL Image with palette applied
        """
        img = Image.open(image_path)
        return self.apply_palette_to_pil_image(img, palette_hex_colors, blur_radius=blur_radius)
    
    def preview_recolored_image(self, image_path, palette_hex_colors, max_size=(800, 600)):
        """
        Create a preview of recolored image
        
        Args:
            image_path: Path to the image file
            palette_hex_colors: List of hex colors
            max_size: Maximum preview size (width, height)
        
        Returns:
            PhotoImage for Tkinter display
        """
        img = Image.open(image_path)
        img.thumbnail(max_size, Image.Resampling.LANCZOS)
        recolored = self.apply_palette_to_pil_image(img, palette_hex_colors)
        
        # Resize for preview if needed
        recolored.thumbnail(max_size, Image.Resampling.LANCZOS)
        
        return ImageTk.PhotoImage(recolored)
    
    def save_recolored_image(self, image_path, palette_hex_colors, output_path):
        """
        Save recolored image to file
        
        Args:
            image_path: Path to input image
            palette_hex_colors: List of hex colors
            output_path: Path to save output image
        """
        recolored = self.apply_palette_to_image(image_path, palette_hex_colors)
        recolored.save(output_path)
        return output_path
</file>

<file path="language_manager.py">
"""
Multilingual support module
Korean/English UI text management
"""

class LanguageManager:
    """Language management class"""
    
    # Korean text
    KOREAN = {
        # Menu
        'menu_file': 'ÌååÏùº',
        'menu_edit': 'Ìé∏Ïßë',
        'menu_view': 'Î≥¥Í∏∞',
        'menu_settings': 'ÏÑ§Ï†ï',
        'menu_help': 'ÎèÑÏõÄÎßê',
        
        # File menu
        'file_new': 'ÏÉàÎ°ú ÎßåÎì§Í∏∞...',
        'file_open': 'Ïó¥Í∏∞...',
        'file_save': 'Ï†ÄÏû•...',
        'file_save_as': 'Îã§Î•∏ Ïù¥Î¶ÑÏúºÎ°ú Ï†ÄÏû•...',
        'file_import': 'Í∞ÄÏ†∏Ïò§Í∏∞',
        'file_export': 'ÎÇ¥Î≥¥ÎÇ¥Í∏∞',
        'file_exit': 'Ï¢ÖÎ£å',
        
        # Edit menu
        'edit_copy': 'Î≥µÏÇ¨',
        'edit_paste': 'Î∂ôÏó¨ÎÑ£Í∏∞',
        'edit_clear': 'ÏßÄÏö∞Í∏∞',
        
        # Settings menu
        'settings_title': 'ÏÑ§Ï†ï...',
        'settings_language': 'Ïñ∏Ïñ¥',
        'settings_theme': 'ÌÖåÎßà',
        'settings_api': 'AI ÏÑ§Ï†ï...',
        
        # Theme
        'theme_light': 'ÎùºÏù¥Ìä∏ ÌÖåÎßà',
        'theme_dark': 'Îã§ÌÅ¨ ÌÖåÎßà',
        
        # Main UI
        'title': 'ÏÉâÏÉÅ ÌåîÎ†àÌä∏ ÏÉùÏÑ±Í∏∞',
        'color_input': 'ÏÉâÏÉÅ ÏûÖÎ†•',
        'pick_color': 'ÏÉâÏÉÅ ÏÑ†ÌÉù',
        'from_screen': 'ÌôîÎ©¥ÏóêÏÑú Ï∂îÏ∂ú',
        'from_image': 'Ïù¥ÎØ∏ÏßÄÏóêÏÑú',
        'upload_image': 'Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú',
        'generate_palette': 'ÌåîÎ†àÌä∏ ÏÉùÏÑ±',
        'clear_all': 'Î™®Îëê ÏßÄÏö∞Í∏∞',
        'select_image': 'Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù...',
        'no_file_selected': 'ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå',
        'extract_from_screen': 'ÌôîÎ©¥ÏóêÏÑú Ï∂îÏ∂ú',
        'generate': 'ÏÉùÏÑ±',
        'random_color': 'ÎûúÎç§ ÏÉâÏÉÅ',
        'harmony_options': 'Ï°∞Ìôî ÏòµÏÖò',
        'untitled': 'Ï†úÎ™©ÏóÜÏùå',
        'open_recent': 'ÏµúÍ∑º ÌååÏùº Ïó¥Í∏∞',
        'reset_to_defaults': 'Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞Ìôî',
        'tools': 'ÎèÑÍµ¨',
        'apply_palette_to_image': 'Ïù¥ÎØ∏ÏßÄÏóê ÌåîÎ†àÌä∏ Ï†ÅÏö©...',
        'custom_color_harmonies': 'Ïª§Ïä§ÌÖÄ ÏÉâÏÉÅ Ï°∞Ìôî...',
        'preset_palettes': 'ÌîÑÎ¶¨ÏÖã ÌåîÎ†àÌä∏...',
        
        # Color harmonies
        'complementary': 'Î≥¥ÏÉâ',
        'analogous': 'Ïú†ÏÇ¨ÏÉâ',
        'triadic': 'ÏÇºÍ∞Å Ï°∞ÌôîÏÉâ',
        'monochromatic': 'Îã®ÏÉâ Ï°∞Ìôî',
        'split_complementary': 'Ïä§ÌîåÎ¶ø Î≥¥ÏÉâ',
        'square': 'Ïä§ÌÄòÏñ¥',
        'tetradic': 'ÌÖåÌä∏ÎùºÎîï',
        'double_complementary': 'ÎçîÎ∏î Î≥¥ÏÉâ',
        
        # AI palette
        'ai_palette': 'AI ÌåîÎ†àÌä∏',
        'ai_generate': 'ÏÉùÏÑ±',
        'ai_clear': 'ÏßÄÏö∞Í∏∞',
        'ai_keywords': 'ÌÇ§ÏõåÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)',
        'ai_num_palettes': 'ÌåîÎ†àÌä∏ Í∞úÏàò',
        'ai_num_colors': 'ÏÉâÏÉÅ Í∞úÏàò',
        'ai_generating': 'AI ÌåîÎ†àÌä∏ ÏÉùÏÑ± Ï§ë...',
        'ai_no_palettes': 'AI ÌåîÎ†àÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§. ÏÉùÏÑ± Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÏÉùÏÑ±ÌïòÏÑ∏Ïöî.',
        
        # Saved palettes
        'saved_palettes': 'Ï†ÄÏû•Îêú ÌåîÎ†àÌä∏',
        'save_current': 'ÌòÑÏû¨ ÌåîÎ†àÌä∏ Ï†ÄÏû•',
        'rename': 'Ïù¥Î¶Ñ Î∞îÍæ∏Í∏∞',
        'edit_palette': 'ÌåîÎ†àÌä∏ Ìé∏Ïßë',
        'save_palette': 'ÌåîÎ†àÌä∏ Ï†ÄÏû•',
        'delete_palette': 'ÌåîÎ†àÌä∏ ÏÇ≠Ï†ú',
        'export_txt': 'TXTÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞',
        'export_png': 'PNGÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞',
        
        # Palette editor
        'palette_editor': 'ÌåîÎ†àÌä∏ Ìé∏Ïßë',
        'add_color': 'ÏÉâÏÉÅ Ï∂îÍ∞Ä',
        'delete_color': 'ÏÉâÏÉÅ ÏÇ≠Ï†ú',
        'hsv_adjust': 'HSV Ï°∞Ï†ï',
        'reset': 'Ï¥àÍ∏∞Ìôî',
        'apply': 'Ï†ÅÏö©',
        
        # HSV adjustment
        'hsv_dialog_title': 'ÏÉâÏÉÅ Ï°∞Ï†ï (HSV)',
        'hue': 'ÏÉâÏ°∞ (Hue)',
        'saturation': 'Ï±ÑÎèÑ (Saturation)',
        'value': 'Î™ÖÎèÑ (Value)',
        'brightness': 'Î∞ùÍ∏∞',
        'contrast': 'ÎåÄÎπÑ',
        'warmth': 'ÏÉâÏò®ÎèÑ',
        
        # Messages
        'error': 'Ïò§Î•ò',
        'warning': 'Í≤ΩÍ≥†',
        'info': 'Ï†ïÎ≥¥',
        'success': 'ÏÑ±Í≥µ',
        'confirm_delete': 'Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        'save_success': 'Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.',
        'load_success': 'Î∂àÎü¨ÏôîÏäµÎãàÎã§.',
        'invalid_color': 'ÏûòÎ™ªÎêú ÏÉâÏÉÅ ÏΩîÎìúÏûÖÎãàÎã§.',
        'api_error': 'API Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
        'no_color': 'ÏÉâÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.',

        # main.py common messages (image/save/load)
        'save_error_title': 'Ï†ÄÏû• Ïò§Î•ò',
        'load_error_title': 'Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò',
        'msg_large_file_title': 'ÌÅ∞ ÌååÏùº',
        'msg_large_file_prompt': 'ÌååÏùº ÌÅ¨Í∏∞Í∞Ä {size_mb}MBÏûÖÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        'msg_thumbnail_failed': 'Ïù¥ÎØ∏ÏßÄ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.',
        'msg_image_load_failed': 'Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®: {error}',
        'msg_permission_denied_write': 'ÌååÏùºÏóê Ïì∞Í∏∞ Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.',
        'msg_disk_error': 'ÎîîÏä§ÌÅ¨ Ïò§Î•ò: {error}',
        'msg_save_failed': 'Ï†ÄÏû• Ïã§Ìå®: {error}',
        'msg_load_failed': 'Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®: {error}',

        'msg_color_picker_failed': 'ÏÉâÏÉÅ ÏÑ†ÌÉùÍ∏∞ Ïò§Î•ò: {error}',
        'msg_screen_picker_failed': 'ÌôîÎ©¥ Ï∂îÏ∂ú Ïò§Î•ò: {error}',
        'msg_capture_failed': 'ÌôîÎ©¥ Ï∫°Ï≤ò Ïã§Ìå®: {error}',
        'msg_save_screenshot_failed': 'Ïä§ÌÅ¨Î¶∞ÏÉ∑ ÏòÅÏó≠ Ï†ÄÏû• Ïã§Ìå®: {error}',

        'msg_generate_palette_first': 'Ï†ÄÏû•ÌïòÍ∏∞ Ï†ÑÏóê Î®ºÏ†Ä ÌåîÎ†àÌä∏Î•º ÏÉùÏÑ±ÌïòÏÑ∏Ïöî.',
        'msg_save_txt_failed': 'TXT Ï†ÄÏû• Ïã§Ìå®: {error}',
        'msg_save_png_failed': 'PNG Ï†ÄÏû• Ïã§Ìå®: {error}',
        'msg_saved_txt_summary': '{count}Í∞úÏùò TXT ÌååÏùºÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§: {dest_dir}',
        'msg_saved_png_summary': '{count}Í∞úÏùò PNG ÌååÏùºÏùÑ Ï†ÄÏû•ÌñàÏäµÎãàÎã§: {dest_dir}',
        'msg_select_harmony_required': 'ÏµúÏÜå ÌïòÎÇòÏùò ÏÉâÏÉÅ Ï°∞ÌôîÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',

        'input_error_title': 'ÏûÖÎ†• Ïò§Î•ò',

        'msg_ai_api_key_required': 'AI ÏÑ§Ï†ïÏóêÏÑú API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.',
        'msg_ai_init_failed': 'AI Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {error}',
        'msg_palette_generation_failed': 'ÌåîÎ†àÌä∏ ÏÉùÏÑ± Ïã§Ìå®: {error}',
        'msg_display_palettes_failed': 'ÌåîÎ†àÌä∏ ÌëúÏãú Ïã§Ìå®: {error}',

        'msg_invalid_hex_prompt': 'Ïò¨Î∞îÎ•∏ HEX ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: #3498db).',
        'msg_select_image_first': 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',
        'msg_image_file_not_found': 'Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        'msg_extract_colors_failed': 'Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÏÉâÏÉÅÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏäµÎãàÎã§.',

        'msg_export_png_failed': 'PNG ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: {error}',

        'export_txt_palette_label': 'ÌåîÎ†àÌä∏: {name}',
        'export_txt_color_count_label': 'ÏÉâÏÉÅ Í∞úÏàò: {count}',
        'msg_export_txt_failed': 'TXT ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: {error}',

        'custom_harmony_default_name': 'Ïª§Ïä§ÌÖÄ Ï°∞Ìï©',

        'msg_no_saved_palettes': 'Ï†ÄÏû•Îêú ÌåîÎ†àÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§.\nÎ®ºÏ†Ä ÌåîÎ†àÌä∏Î•º ÏÉùÏÑ±ÌïòÍ≥† Ï†ÄÏû•ÌïòÏÑ∏Ïöî.',

        'jpeg_image': 'JPEG Ïù¥ÎØ∏ÏßÄ',
        'msg_load_image_first': 'Î®ºÏ†Ä Ïù¥ÎØ∏ÏßÄÎ•º Î∂àÎü¨Ïò§ÏÑ∏Ïöî.',
        'msg_empty_palette_cannot_apply': 'Îπà ÌåîÎ†àÌä∏Îäî Ï†ÅÏö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.',
        'msg_recolor_load_image_failed': 'Ïù¥ÎØ∏ÏßÄ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®: {error}',
        'msg_recolor_display_failed': 'Ïù¥ÎØ∏ÏßÄ ÌëúÏãú Ïã§Ìå®: {error}',
        'msg_recolor_save_success': 'ÌåîÎ†àÌä∏Í∞Ä Ï†ÅÏö©Îêú Ïù¥ÎØ∏ÏßÄÎ•º Ï†ÄÏû•ÌñàÏäµÎãàÎã§:\n{path}',
        'msg_recolor_save_failed': 'Ï†ÄÏû• Ïã§Ìå®: {error}',
        'msg_recolor_preview_failed': 'ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÉùÏÑ± Ïã§Ìå®: {error}',
        'msg_image_loaded': 'Ïù¥ÎØ∏ÏßÄÍ∞Ä Î°úÎìúÎêòÏóàÏäµÎãàÎã§: {filename}',

        'msg_palette_has_no_colors': 'ÌåîÎ†àÌä∏Ïóê ÏÉâÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.',
        'msg_no_valid_colors': 'Ïú†Ìö®Ìïú ÏÉâÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.',
        'msg_color_adjust_unavailable': 'ÏÉâÏÉÅ Ï°∞Ï†ï Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.',
        'msg_color_adjust_failed': 'ÏÉâÏÉÅ Ï°∞Ï†ï Ïã§Ìå®: {error}',

        # Common display/format
        'ellipsis': '...',
        'rgb_unknown': '(?, ?, ?)',
        'label_numbered_rgb': '{i}. RGB: {value}',
        'tooltip_recent_color_info': 'RGB: {rgb}\nHEX: {hex}\nÌùëÎ∞±Í∞í: {lum}',
        'custom_harmony_numbered': 'Ïª§Ïä§ÌÖÄ {i}',

        # Settings UI
        'settings_window_size_separator': 'x',

        # Preset palettes
        'preset_tags_format': '({tags})',

        # Export (TXT/PNG) file content
        'export_txt_file_header': 'ÌåîÎ†àÌä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞: {timestamp}',
        'export_txt_palette_title': 'ÌåîÎ†àÌä∏ {i}',
        'export_txt_line_base': 'Í∏∞Î≥∏: {hex} | RGB: {rgb}',
        'export_txt_line_complementary': 'Î≥¥ÏÉâ: {hex} | RGB: {rgb}',
        'export_txt_section_analogous': 'Ïú†ÏÇ¨ÏÉâ:',
        'export_txt_section_triadic': 'ÏÇºÍ∞Å Ï°∞ÌôîÏÉâ:',
        'export_txt_section_monochromatic': 'Îã®ÏÉâ Ï°∞Ìôî:',
        'export_txt_color_line': '{hex} | RGB: {rgb}',
        'export_txt_indexed_color_line': '{i}. {hex} | RGB: {rgb}',

        'export_png_palette_title': 'ÌåîÎ†àÌä∏ {i}',
        'export_png_label_base': 'Í∏∞Î≥∏',
        'export_png_label_complementary': 'Î≥¥ÏÉâ',
        'export_png_label_analogous': 'Ïú†ÏÇ¨ÏÉâ',
        'export_png_label_triadic': 'ÏÇºÍ∞Å',
        'export_png_label_monochromatic': 'Îã®ÏÉâ',
        'export_png_label_numbered': '{label} {i}',
        
        # Buttons
        'ok': 'ÌôïÏù∏',
        'yes': 'Ïòà',
        'no': 'ÏïÑÎãàÏò§',
        
        # Other
        'base_color': 'Í∏∞Î≥∏ ÏÉâÏÉÅ',
        'representative_color': 'ÎåÄÌëú ÏÉâÏÉÅ',
        'palette_name': 'ÌåîÎ†àÌä∏ Ïù¥Î¶Ñ',
        'new_name': 'ÏÉà Ïù¥Î¶Ñ',
        'enter_name': 'Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî',
        
        # Palette list button tooltips
        'tooltip_add_palette': 'ÌåîÎ†àÌä∏ Ï∂îÍ∞Ä',
        'tooltip_delete_palette': 'ÌåîÎ†àÌä∏ Ï†úÍ±∞',
        'tooltip_copy_palette': 'ÌåîÎ†àÌä∏ Î≥µÏÇ¨',
        'tooltip_load_palette': 'ÌåîÎ†àÌä∏ Î∂àÎü¨Ïò§Í∏∞',
        'tooltip_adjust_color': 'ÏÉâÏÉÅ Ï°∞Ï†ï',
        
        # File dialogs
        'dialog_select_image': 'Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù',
        'dialog_save_pgf': 'PGFÎ°ú Ï†ÄÏû•...',
        'dialog_save_as': 'Îã§Î•∏ Ïù¥Î¶ÑÏúºÎ°ú Ï†ÄÏû•...',
        'dialog_open_pgf': 'PGF Ïó¥Í∏∞...',
        'dialog_select_image_recolor': 'Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù',
        'dialog_save_recolored': 'ÌåîÎ†àÌä∏ Ï†ÅÏö© Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•',
        
        # Color selection dialogs
        'harmonies_title': 'ÏÉâÏÉÅ Ï°∞Ìôî ÏÑ†ÌÉù',
        'select_harmonies': 'ÌëúÏãúÌï† ÏÉâÏÉÅ Ï°∞ÌôîÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:',
        'custom_harmonies': 'Ïª§Ïä§ÌÖÄ ÏÉâÏÉÅ Ï°∞Ìôî:',
        'pick_color_title': 'ÏÉâÏÉÅ ÏÑ†ÌÉù',
        'add_color_title': 'ÏÉâÏÉÅ Ï∂îÍ∞Ä',
        'edit_color_title': 'ÏÉâÏÉÅ ÏàòÏ†ï',
        
        # Color box tooltip
        'tooltip_color_box': 'ÏôºÏ™Ω ÌÅ¥Î¶≠: ÌåîÎ†àÌä∏Ïóê Ï∂îÍ∞Ä\nÏò§Î•∏Ï™Ω ÌÅ¥Î¶≠: Í∏∞Î≥∏ ÏÉâÏÉÅÏúºÎ°ú ÏÑ§Ï†ï',
        
        # Palette edit buttons
        'sort_by_hue': 'ÏÉâÏ°∞ Ï†ïÎ†¨',
        'sort_by_saturation': 'Ï±ÑÎèÑ Ï†ïÎ†¨',
        'sort_by_luminance': 'Î∞∏Î•ò Ï†ïÎ†¨',
        'sort_reverse': 'Ïó≠Ïàú Ï†ïÎ†¨',
        'show_values': 'Í∞í Î≥¥Í∏∞',
        
        # Loading/status messages
        'screenshot_label': '**Ïä§ÌÅ¨Î¶∞ÏÉ∑**',
        'no_image_label': 'Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§.',
        'empty_palette': 'Îπà ÌåîÎ†àÌä∏ÏûÖÎãàÎã§',
        'generating_ai': 'AI ÌåîÎ†àÌä∏ ÏÉùÏÑ± Ï§ë...',
        
        # Settings dialog sections
        'settings_theme_section': 'ÌÖåÎßà ÏÑ§Ï†ï',
        
        # Settings options
        'language_label': 'Ïñ∏Ïñ¥:',
        'theme_label': 'ÌÖåÎßà:',
        'autosave_enable': 'ÏûêÎèô Ï†ÄÏû• ÏÇ¨Ïö©',
        'autosave_interval': 'ÏûêÎèô Ï†ÄÏû• Í∞ÑÍ≤© (Ï¥à):',
        'max_colors': 'ÏµúÎåÄ ÏÉâÏÉÅ Ïàò:',
        'filter_background': 'Î∞∞Í≤ΩÏÉâ ÌïÑÌÑ∞ÎßÅ (Ìù∞ÏÉâ/Í≤ÄÏùÄÏÉâ Ï†úÏô∏)',
        'window_size': 'Ï∞Ω ÌÅ¨Í∏∞:',
        'recent_files_count': 'ÏµúÍ∑º ÌååÏùº Ïàò:',
        
        # Image recolor dialog
        'select_palette_label': 'ÌåîÎ†àÌä∏ ÏÑ†ÌÉù:',
        'load_image_btn': 'Ïù¥ÎØ∏ÏßÄ Î∂àÎü¨Ïò§Í∏∞',
        'view_original_btn': 'ÏõêÎ≥∏ ÌÅ¨Í∏∞Î°ú Î≥¥Í∏∞',
        'save_btn': 'Ï†ÄÏû•',
        'close_btn': 'Îã´Í∏∞',
        'preview_label': 'ÎØ∏Î¶¨Î≥¥Í∏∞',
        
        # AI settings dialog
        'ai_api_key_label': 'Gemini API ÌÇ§:',
        'ai_api_help': 'API ÌÇ§Îäî https://aistudio.google.com/app/apikey ÏóêÏÑú Î∞úÍ∏âÎ∞õÏùÑ Ïàò ÏûàÏäµÎãàÎã§.',
        'ai_colors_per_palette': 'ÌåîÎ†àÌä∏Îãπ ÏÉâÏÉÅ Í∞úÏàò:',
        'ai_keywords_label': 'ÌÇ§ÏõåÎìú (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ):',
        'ai_keywords_example': 'Ïòà: ocean, calm, blue',
        'ai_test_api': 'API ÌÇ§ ÌÖåÏä§Ìä∏',
        
        # General
        'image_files': 'Ïù¥ÎØ∏ÏßÄ ÌååÏùº',
        'all_files': 'Î™®Îì† ÌååÏùº',
        
        # Dialog titles
        'dialog_settings': 'ÏÑ§Ï†ï',
        'dialog_palette_editor': 'ÌåîÎ†àÌä∏ Ìé∏Ïßë',
        'dialog_ai_settings': 'AI ÏÑ§Ï†ï',
        'dialog_select_harmonies': 'ÏÉâÏÉÅ Ï°∞Ìôî ÏÑ†ÌÉù',
        'dialog_apply_palette': 'ÌåîÎ†àÌä∏ Ï†ÅÏö©',
        'dialog_custom_harmony': 'Ïª§Ïä§ÌÖÄ ÏÉâÏÉÅ Ï°∞Ìôî',
        'dialog_preset_palettes': 'ÌîÑÎ¶¨ÏÖã ÌåîÎ†àÌä∏',
        'dialog_rename_palette': 'ÌåîÎ†àÌä∏ Ïù¥Î¶Ñ Î≥ÄÍ≤Ω',

        # Common
        'unnamed': 'Ïù¥Î¶ÑÏóÜÏùå',
        'done': 'ÏôÑÎ£å',

        # Module/Dialog errors
        'custom_harmony_module_missing': 'Ïª§Ïä§ÌÖÄ Ï°∞Ìï© Î™®ÎìàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        'custom_harmony_open_failed': 'Ïª§Ïä§ÌÖÄ Ï°∞Ìï© Ïó¥Í∏∞ Ïã§Ìå®: {error}',
        'preset_module_missing': 'ÌîÑÎ¶¨ÏÖã ÌåîÎ†àÌä∏ Î™®ÎìàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        'preset_open_failed': 'ÌîÑÎ¶¨ÏÖã ÌåîÎ†àÌä∏ Ïó¥Í∏∞ Ïã§Ìå®: {error}',

        # Preset palettes
        'preset_added_title': 'ÌåîÎ†àÌä∏ Ï∂îÍ∞ÄÎê®',
        'preset_added_msg': '"{name}" ÌåîÎ†àÌä∏Î•º Ï†ÄÏû•Îêú ÌåîÎ†àÌä∏Ïóê Ï∂îÍ∞ÄÌñàÏäµÎãàÎã§.',
        'preset_pick_search_color': 'Í≤ÄÏÉâÌï† ÏÉâÏÉÅ ÏÑ†ÌÉù',

        # Custom harmony
        'custom_harmony_select_delete': 'ÏÇ≠Ï†úÌï† Ï°∞Ìï©ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',
        'custom_harmony_confirm_delete': 'Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        'custom_harmony_name_required': 'Ï°∞Ìï© Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.',
        'custom_harmony_color_required': 'ÏµúÏÜå ÌïòÎÇòÏùò ÏÉâÏÉÅÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.',
        'custom_harmony_saved': 'Ï°∞Ìï©Ïù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.',
        'custom_harmony_hsv_item': '{i}. HSV (H:{h:+.0f}¬∞, S:{s:+.0f}%, V:{v:+.0f}%)',
        'custom_harmony_fixed_item': '{i}. Í≥†Ï†ï ÏÉâÏÉÅ: {hex}',
        
        # Settings window messages
        'settings_saved': 'ÏÑ§Ï†ïÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.\nÏñ∏Ïñ¥ Î≥ÄÍ≤ΩÏùÄ Ïû¨ÏãúÏûë ÌõÑ Ï†ÅÏö©Îê©ÎãàÎã§.',
        'settings_save_failed': 'ÏÑ§Ï†ï Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.',
        'settings_saved_title': 'Ï†ÄÏû• ÏôÑÎ£å',
        'settings_save_failed_title': 'Ï†ÄÏû• Ïã§Ìå®',
        
        # AI error messages
        'ai_quota_exceeded': 'API ÏÇ¨Ïö©Îüâ ÌïúÍ≥ÑÏóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§.\nÏû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌïòÍ±∞ÎÇò API ÌÇ§Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.',
        'ai_api_test_success': 'API ÌÇ§Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏûëÎèôÌï©ÎãàÎã§!',
        'ai_api_test_failed': 'API ÌÇ§ ÌÖåÏä§Ìä∏ Ïã§Ìå®: {error}',
        'ai_api_invalid_key': 'API ÌÇ§Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.',
        'ai_api_network_error': 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.',
        'ai_generation_failed': 'AI ÌåîÎ†àÌä∏ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: {error}',

        # ai_color_recommender.py
        'ai_recommender_missing_library': "google-generativeai ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.\n'{install_cmd}'Î•º Ïã§ÌñâÌïòÏÑ∏Ïöî.",
        'ai_recommender_init_failed': 'Gemini Î™®Îç∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {error}',
        'ai_recommender_api_key_not_set': 'API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.',
        'ai_recommender_generation_failed': 'AI ÌåîÎ†àÌä∏ ÏÉùÏÑ± Ïã§Ìå®: {error}',
        'ai_recommender_test_prompt': "Say 'OK' if you can read this.",
        'ai_recommender_test_success': 'API ÌÇ§Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏûëÎèôÌï©ÎãàÎã§.',
        'ai_recommender_test_no_response': 'ÏùëÎãµÏùÑ Î∞õÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        'ai_recommender_test_failed': 'API ÌÇ§ ÌÖåÏä§Ìä∏ Ïã§Ìå®: {error}',
        'ai_recommender_prompt_with_keywords': """Create {num_palettes} color palettes ({num_colors} colors each) based on: {keywords}
    Format: PaletteName: #HEX,#HEX,#HEX,#HEX,#HEX
    Example: Ocean Breeze: #0077BE,#00A8E8,#48CAE4,#90E0EF,#ADE8F4
    Give each palette a creative 2-3 word name. Output only palette lines.""",
        'ai_recommender_prompt_without_keywords': """Create {num_palettes} diverse color palettes ({num_colors} colors each).
    Format: PaletteName: #HEX,#HEX,#HEX,#HEX,#HEX
    Example: Sunset Warm: #FF6B35,#F7931E,#FDC830,#F37335,#C0392B
    Give each palette a creative 2-3 word name. Output only palette lines.""",
        
        # Palette editor messages
        'palette_editor_title': 'ÌåîÎ†àÌä∏ Ìé∏Ïßë - {name}',
        'color_added': 'ÏÉâÏÉÅÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.',
        'color_edited': 'ÏÉâÏÉÅÏù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.',
        'select_color_first': 'Î®ºÏ†Ä ÏÉâÏÉÅÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.',
        
        # Context menu
        'context_rename': 'Ïù¥Î¶Ñ Î∞îÍæ∏Í∏∞',
        'context_edit_palette': 'ÌåîÎ†àÌä∏ Ìé∏Ïßë',
        'context_save_palette': 'ÌåîÎ†àÌä∏ Ï†ÄÏû•',
        'context_export_txt': 'TXTÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞',
        'context_export_png': 'PNGÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞',
        'context_toggle_view': 'RGBÎ°ú Î≥¥Í∏∞',
        
        # Settings dialog
        'settings_language_section': 'Ïñ∏Ïñ¥ ÏÑ§Ï†ï',
        'settings_autosave_section': 'ÏûêÎèô Ï†ÄÏû• ÏÑ§Ï†ï',
        'settings_extraction_section': 'ÏÉâÏÉÅ Ï∂îÏ∂ú ÏÑ§Ï†ï',
        'settings_ui_section': 'UI ÏÑ§Ï†ï',
        'settings_autosave_enable': 'ÏûêÎèô Ï†ÄÏû• ÏÇ¨Ïö©',
        'settings_autosave_interval': 'ÏûêÎèô Ï†ÄÏû• Í∞ÑÍ≤© (Ï¥à):',
        'settings_max_colors': 'ÏµúÎåÄ ÏÉâÏÉÅ Ïàò:',
        'settings_filter_background': 'Î∞∞Í≤ΩÏÉâ ÌïÑÌÑ∞ÎßÅ (Ìù∞ÏÉâ/Í≤ÄÏùÄÏÉâ Ï†úÏô∏)',
        'settings_window_size': 'Ï∞Ω ÌÅ¨Í∏∞:',
        'settings_recent_files': 'ÏµúÍ∑º ÌååÏùº Ïàò:',
        'settings_recent_colors': 'ÏµúÍ∑º ÏÇ¨Ïö© ÏÉâÏÉÅ ÏµúÎåÄ Ïàò:',
        'button_save': 'Ï†ÄÏû•',
        'button_close': 'Îã´Í∏∞',
        
        # Image recoloring dialog
        'recolor_select_palette': 'ÌåîÎ†àÌä∏ ÏÑ†ÌÉù:',
        'recolor_load_image': 'Ïù¥ÎØ∏ÏßÄ Î∂àÎü¨Ïò§Í∏∞',
        'recolor_view_original': 'ÏõêÎ≥∏ ÌÅ¨Í∏∞Î°ú Î≥¥Í∏∞',
        'recolor_preview': 'ÎØ∏Î¶¨Î≥¥Í∏∞',
        'recolor_empty_palette': 'Îπà ÌåîÎ†àÌä∏ÏûÖÎãàÎã§',
        
        # Preset palette dialog
        'preset_filter': 'ÌïÑÌÑ∞:',
        'preset_all': 'Î™®Îëê',
        'preset_search_color': 'ÏÉâÏÉÅÏúºÎ°ú Í≤ÄÏÉâ',
        'preset_reset_filter': 'ÌïÑÌÑ∞ Ï¥àÍ∏∞Ìôî',
        'preset_count': '{current} / {total} ÌåîÎ†àÌä∏',
        'preset_use': 'ÏÇ¨Ïö©',
        
        # Color harmony labels
        'base_color_label': 'Í∏∞Î≥∏ ÏÉâÏÉÅ',
        'complementary_label': 'Î≥¥ÏÉâ',
        'analogous_label': 'Ïú†ÏÇ¨ÏÉâ',
        'triadic_label': 'ÏÇºÍ∞Å Ï°∞ÌôîÏÉâ',
        'color_box_tooltip': 'Ï¢åÌÅ¥Î¶≠: ÌåîÎ†àÌä∏Ïóê Ï∂îÍ∞Ä\nÏö∞ÌÅ¥Î¶≠: Í∏∞Î≥∏ ÏÉâÏÉÅÏúºÎ°ú ÏÑ§Ï†ï',
        
        # Recent colors
        'recent_colors_title': 'ÏµúÍ∑º ÏÇ¨Ïö© ÏÉâÏÉÅ',
        'recent_colors_clear': 'Í∏∞Î°ù ÏßÄÏö∞Í∏∞',
        'recent_colors_empty': 'ÏµúÍ∑º ÏÇ¨Ïö©Ìïú ÏÉâÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§',
        
        # Palette selection
        'selection_required': 'ÏÑ†ÌÉù ÌïÑÏöî',
        'select_palette_first': 'Î®ºÏ†Ä Ïò§Î•∏Ï™ΩÏóêÏÑú Ï†ÄÏû•Îêú ÌåîÎ†àÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',
        'select_palette_to_adjust': 'Ï°∞Ï†ïÌï† ÌåîÎ†àÌä∏Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.',
        'saved_palette_default_name': 'Ï†ÄÏû•Îêú ÌåîÎ†àÌä∏',
        'palette_numbered': 'ÌåîÎ†àÌä∏{i}',
        'copy_suffix': ' (Î≥µÏÇ¨)',
        'new_palette_numbered': 'ÏÉà ÌåîÎ†àÌä∏{i}',
        'unknown': 'Ïïå Ïàò ÏóÜÏùå',
        'tooltip_palette_color_info': '{hex}\nRGB: {rgb}\nÌùëÎ∞±Í∞í: {lum}/255',
        'msg_set_base_color_failed': 'Î≤†Ïù¥Ïä§ ÏÉâÏÉÅ ÏÑ§Ï†ï Ïã§Ìå®:\n{error}',

        'color_adjuster_title': 'ÏÉâÏÉÅ Ï°∞Ï†ï',
        'warmth_hint': '(Ï∞®Í∞ÄÏõÄ ‚Üê ‚Üí Îî∞ÎúªÌï®)',
        'label_rgb': 'RGB: {value}',
        'label_hex': 'HEX: {value}',
        'dialog_open_mps': 'ÌåîÎ†àÌä∏ ÌååÏùº Ïó¥Í∏∞',
        'saved_palettes_list': 'Ï†ÄÏû•Îêú ÌåîÎ†àÌä∏ Î™©Î°ù',
        'browse_other_file': 'Îã§Î•∏ ÌååÏùº Ï∞æÍ∏∞',
        'load': 'Î∂àÎü¨Ïò§Í∏∞',
        'msg_file_not_found': 'ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        'ai_module_missing': 'AI Ï∂îÏ≤ú Î™®ÎìàÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        'ai_settings_open_failed': 'AI ÏÑ§Ï†ï Ïó¥Í∏∞ Ïã§Ìå®: {error}',
        
        # Accessibility checker
        'accessibility_title': 'Ï†ëÍ∑ºÏÑ± Í≤ÄÏÇ¨',
        'accessibility_check': 'ÎåÄÎπÑÏú® Í≤ÄÏÇ¨',
        'accessibility_wcag_aa': 'WCAG AA Í∏∞Ï§Ä',
        'accessibility_wcag_aaa': 'WCAG AAA Í∏∞Ï§Ä',
        'accessibility_ratio': 'ÎåÄÎπÑÏú®: {ratio}:1',
        'accessibility_pass': 'ÌÜµÍ≥º',
        'accessibility_fail': 'Ïã§Ìå®',
        
        # Gradient generator
        'gradient_title': 'Í∑∏ÎùºÎîîÏñ∏Ìä∏ ÏÉùÏÑ±',
        'gradient_steps': 'Îã®Í≥Ñ Ïàò:',
        'gradient_generate': 'ÏÉùÏÑ±',
        'gradient_color_from': 'ÏãúÏûë ÏÉâÏÉÅ',
        'gradient_color_to': 'ÎÅù ÏÉâÏÉÅ',
        
        # Custom harmony editor
        'saved_harmonies': 'Ï†ÄÏû•Îêú Ï°∞Ìï©',
        'delete_harmony': 'ÏÇ≠Ï†ú',
        'color_list': 'ÏÉâÏÉÅ Î™©Î°ù',
        'colors': 'ÏÉâÏÉÅ',
        'fixed_color': 'Í≥†Ï†ï ÏÉâÏÉÅ',
        'add_hsv_color': 'HSV ÏÉâÏÉÅ Ï∂îÍ∞Ä',
        'edit_hsv_color': 'HSV ÏÉâÏÉÅ ÏàòÏ†ï',
        'add_fixed_color': 'Í≥†Ï†ï ÏÉâÏÉÅ Ï∂îÍ∞Ä',
        'extract_from_image': 'Ïù¥ÎØ∏ÏßÄÏóêÏÑú Ï∂îÏ∂ú',
        'msg_colors_extracted': '{count}Í∞úÏùò ÏÉâÏÉÅÏù¥ Ï∂îÏ∂úÎêòÏóàÏäµÎãàÎã§.',
        'edit': 'ÏàòÏ†ï',
        'move_up': 'ÏúÑÎ°ú',
        'move_down': 'ÏïÑÎûòÎ°ú',
        'new_harmony': 'ÏÉà Ï°∞Ìï©',
        'harmony_name': 'Ï°∞Ìï© Ïù¥Î¶Ñ',
        'edit_color': 'ÏÉâÏÉÅ ÏàòÏ†ï',
        'preview': 'ÎØ∏Î¶¨Î≥¥Í∏∞',
        
        # CustomTkinter UI additional keys
        'tab_palette': 'ÌåîÎ†àÌä∏',
        'tab_recolor': 'Ïù¥ÎØ∏ÏßÄ Î¶¨Ïª¨Îü¨',
        'tab_custom_harmony': 'Ïª§Ïä§ÌÖÄ Ï°∞Ìôî',
        'color_settings': 'ÏÉâÏÉÅ ÏÑ§Ï†ï',
        'source_type': 'ÏÜåÏä§ Ïú†Ìòï',
        'selected_color': 'ÏÑ†ÌÉùÎêú ÏÉâÏÉÅ',
        'generated_palette': 'ÏÉùÏÑ±Îêú ÌåîÎ†àÌä∏',
        'view_rgb': 'HEXÎ°ú Î≥¥Í∏∞',
        'view_value': 'Î∞∏Î•òÎ°ú Î≥¥Í∏∞',
        'no_recent_files': 'ÏµúÍ∑º ÌååÏùº ÏóÜÏùå',
        'my_palette_file': 'My Palette ÌååÏùº',
        'text_file': 'ÌÖçÏä§Ìä∏ ÌååÏùº',
        'png_image': 'PNG Ïù¥ÎØ∏ÏßÄ',
        'export_title': 'ÎÇ¥Î≥¥ÎÇ¥Í∏∞',
        'save_prompt_title': 'Ï†ÄÏû• ÌôïÏù∏',
        'msg_save_changes_prompt': 'Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ Ï†ÄÏû•ÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        'saved_title': 'Ï†ÄÏû• ÏôÑÎ£å',
        'loaded_title': 'Î∂àÎü¨Ïò§Í∏∞ ÏôÑÎ£å',
        'msg_workspace_saved': 'ÏõåÌÅ¨Ïä§ÌéòÏù¥Ïä§Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§:\n{path}',
        'msg_workspace_loaded': 'ÏõåÌÅ¨Ïä§ÌéòÏù¥Ïä§Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§:\n{path}',
        'msg_no_save_path': 'Ï†ÄÏû• Í≤ΩÎ°úÍ∞Ä ÏßÄÏ†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.',
        'msg_file_not_found_path': 'ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§:\n{path}',
        'reset_settings_title': 'ÏÑ§Ï†ï Ï¥àÍ∏∞Ìôî',
        'msg_reset_settings_confirm': 'Î™®Îì† ÏÑ§Ï†ïÏùÑ Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        'reset_done_title': 'Ï¥àÍ∏∞Ìôî ÏôÑÎ£å',
        'msg_settings_reset_done': 'ÏÑ§Ï†ïÏù¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.',
        'ai_palette_name': 'AI ÌåîÎ†àÌä∏ {i}',
        'ai_generating_title': 'AI ÏÉùÏÑ± Ï§ë',
        'ai_error_title': 'AI Ïò§Î•ò',
        'button_cancel': 'Ï∑®ÏÜå',
        'cancel': 'Ï∑®ÏÜå',
        'empty_palette_msg': 'ÏÉâÏÉÅÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî',
        'colors_count': '{count}Í∞úÏùò ÏÉâÏÉÅ',
        'confirm': 'ÌôïÏù∏',
        'delete': 'ÏÇ≠Ï†ú',
        'msg_no_preview': 'ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä ÏóÜÏäµÎãàÎã§. Î®ºÏ†Ä ÌåîÎ†àÌä∏Î•º Ï†ÅÏö©ÌïòÏÑ∏Ïöî.',
        'select_harmony_prompt': 'Ìé∏ÏßëÌï† Ï°∞Ìï©ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî',
    }    
    # English text
    ENGLISH = {
        # Menu
        'menu_file': 'File',
        'menu_edit': 'Edit',
        'menu_view': 'View',
        'menu_settings': 'Settings',
        'menu_help': 'Help',
        
        # File menu
        'file_new': 'New...',
        'file_open': 'Open...',
        'file_save': 'Save...',
        'file_save_as': 'Save As...',
        'file_import': 'Import',
        'file_export': 'Export',
        'file_exit': 'Exit',
        
        # Edit menu
        'edit_copy': 'Copy',
        'edit_paste': 'Paste',
        'edit_clear': 'Clear',
        
        # Settings menu
        'settings_title': 'Settings...',
        'settings_language': 'Language',
        'settings_theme': 'Theme',
        'settings_api': 'AI Settings...',
        
        # Theme
        'theme_light': 'Light Theme',
        'theme_dark': 'Dark Theme',
        
        # Main UI
        'title': 'Color Palette Generator',
        'color_input': 'Color Input',
        'pick_color': 'Pick Color',
        'from_screen': 'From Screen',
        'from_image': 'From Image',
        'upload_image': 'Upload Image',
        'generate_palette': 'Generate Palette',
        'clear_all': 'Clear All',
        'select_image': 'Select Image...',
        'no_file_selected': 'No file selected',
        'extract_from_screen': 'Extract from Screen',
        'generate': 'Generate',
        'random_color': 'Random Color',
        'harmony_options': 'Harmony Options',
        'untitled': 'Untitled',
        'open_recent': 'Open Recent',
        'reset_to_defaults': 'Reset to Defaults',
        'tools': 'Tools',
        'apply_palette_to_image': 'Apply Palette to Image...',
        'custom_color_harmonies': 'Custom Color Harmonies...',
        'preset_palettes': 'Preset Palettes...',
        
        # Color harmonies
        'complementary': 'Complementary',
        'analogous': 'Analogous',
        'triadic': 'Triadic',
        'monochromatic': 'Monochromatic',
        'split_complementary': 'Split Complementary',
        'square': 'Square',
        'tetradic': 'Tetradic',
        'double_complementary': 'Double Complementary',
        
        # AI palette
        'ai_palette': 'AI Palette',
        'ai_generate': 'Generate',
        'ai_clear': 'Clear',
        'ai_keywords': 'Keywords (optional)',
        'ai_num_palettes': 'Number of Palettes',
        'ai_num_colors': 'Colors per Palette',
        'ai_generating': 'Generating AI palettes...',
        'ai_no_palettes': 'No AI palettes. Click Generate to create.',
        
        # Saved palettes
        'saved_palettes': 'Saved Palettes',
        'save_current': 'Save Current Palette',
        'rename': 'Rename',
        'edit_palette': 'Edit Palette',
        'save_palette': 'Save Palette',
        'delete_palette': 'Delete Palette',
        'export_txt': 'Export as TXT',
        'export_png': 'Export as PNG',
        
        # Palette editor
        'palette_editor': 'Palette Editor',
        'add_color': 'Add Color',
        'delete_color': 'Delete Color',
        'hsv_adjust': 'HSV Adjust',
        'reset': 'Reset',
        'apply': 'Apply',
        
        # HSV adjustment
        'hsv_dialog_title': 'Adjust Color (HSV)',
        'hue': 'Hue',
        'saturation': 'Saturation',
        'value': 'Value',
        'brightness': 'Brightness',
        'contrast': 'Contrast',
        'warmth': 'Warmth',
        
        # Messages
        'error': 'Error',
        'warning': 'Warning',
        'info': 'Information',
        'success': 'Success',
        'confirm_delete': 'Are you sure you want to delete?',
        'save_success': 'Saved successfully.',
        'load_success': 'Loaded successfully.',
        'invalid_color': 'Invalid color code.',
        'api_error': 'API error occurred.',
        'no_color': 'No colors available.',

        # main.py common messages (image/save/load)
        'save_error_title': 'Save Error',
        'load_error_title': 'Load Error',
        'msg_large_file_title': 'Large File',
        'msg_large_file_prompt': 'The file size is {size_mb}MB. Continue?',
        'msg_thumbnail_failed': 'Unable to create image preview.',
        'msg_image_load_failed': 'Failed to load image: {error}',
        'msg_permission_denied_write': 'Permission denied.',
        'msg_disk_error': 'Disk error: {error}',
        'msg_save_failed': 'Failed to save: {error}',
        'msg_load_failed': 'Failed to load: {error}',

        'msg_color_picker_failed': 'Color picker error: {error}',
        'msg_screen_picker_failed': 'Screen picker error: {error}',
        'msg_capture_failed': 'Failed to capture screen: {error}',
        'msg_save_screenshot_failed': 'Failed to save screenshot region: {error}',

        'msg_generate_palette_first': 'Generate a palette first before saving.',
        'msg_save_txt_failed': 'Failed to save TXT: {error}',
        'msg_save_png_failed': 'Failed to save PNG: {error}',
        'msg_saved_txt_summary': 'Saved {count} TXT file(s) to {dest_dir}',
        'msg_saved_png_summary': 'Saved {count} PNG file(s) to {dest_dir}',
        'msg_select_harmony_required': 'Please select at least one color harmony.',

        'input_error_title': 'Input Error',

        'msg_ai_api_key_required': 'Please enter API key in AI Settings.',
        'msg_ai_init_failed': 'AI initialization failed: {error}',
        'msg_palette_generation_failed': 'Palette generation failed: {error}',
        'msg_display_palettes_failed': 'Failed to display palettes: {error}',

        'msg_invalid_hex_prompt': 'Please enter a valid HEX code (e.g., #3498db).',
        'msg_select_image_first': 'Please select an image file.',
        'msg_image_file_not_found': 'Image file not found.',
        'msg_extract_colors_failed': 'Unable to extract colors from the image.',

        'msg_export_png_failed': 'PNG export failed: {error}',

        'export_txt_palette_label': 'Palette: {name}',
        'export_txt_color_count_label': 'Color count: {count}',
        'msg_export_txt_failed': 'TXT export failed: {error}',

        'custom_harmony_default_name': 'Custom Harmony',

        'msg_no_saved_palettes': 'No saved palettes.\nGenerate and save a palette first.',

        'jpeg_image': 'JPEG Image',
        'msg_load_image_first': 'Load an image first.',
        'msg_empty_palette_cannot_apply': 'Cannot apply an empty palette.',
        'msg_recolor_load_image_failed': 'Failed to load image: {error}',
        'msg_recolor_display_failed': 'Failed to display image: {error}',
        'msg_recolor_save_success': 'Saved recolored image:\n{path}',
        'msg_recolor_save_failed': 'Failed to save: {error}',
        'msg_recolor_preview_failed': 'Failed to generate preview: {error}',
        'msg_image_loaded': 'Image loaded: {filename}',

        'msg_palette_has_no_colors': 'No colors in the palette.',
        'msg_no_valid_colors': 'No valid colors.',
        'msg_color_adjust_unavailable': 'Color adjustment is not available.',
        'msg_color_adjust_failed': 'Color adjustment failed: {error}',

        # Common display/format
        'ellipsis': '...',
        'rgb_unknown': '(?, ?, ?)',
        'label_numbered_rgb': '{i}. RGB: {value}',
        'tooltip_recent_color_info': 'RGB: {rgb}\nHEX: {hex}\nLuminance: {lum}',
        'custom_harmony_numbered': 'Custom {i}',

        # Settings UI
        'settings_window_size_separator': 'x',

        # Preset palettes
        'preset_tags_format': '({tags})',

        # Export (TXT/PNG) file content
        'export_txt_file_header': 'Palettes exported: {timestamp}',
        'export_txt_palette_title': 'Palette {i}',
        'export_txt_line_base': 'Base: {hex} | RGB: {rgb}',
        'export_txt_line_complementary': 'Complementary: {hex} | RGB: {rgb}',
        'export_txt_section_analogous': 'Analogous:',
        'export_txt_section_triadic': 'Triadic:',
        'export_txt_section_monochromatic': 'Monochromatic:',
        'export_txt_color_line': '{hex} | RGB: {rgb}',
        'export_txt_indexed_color_line': '{i}. {hex} | RGB: {rgb}',

        'export_png_palette_title': 'Palette {i}',
        'export_png_label_base': 'Base',
        'export_png_label_complementary': 'Complementary',
        'export_png_label_analogous': 'Analogous',
        'export_png_label_triadic': 'Triadic',
        'export_png_label_monochromatic': 'Monochromatic',
        'export_png_label_numbered': '{label} {i}',
        
        # Buttons
        'ok': 'OK',
        'yes': 'Yes',
        'no': 'No',
        
        # Other
        'base_color': 'Base Color',
        'representative_color': 'Representative Color',
        'palette_name': 'Palette Name',
        'new_name': 'New Name',
        'enter_name': 'Enter name',
        
        # Palette list button tooltips
        'tooltip_add_palette': 'Add Palette',
        'tooltip_delete_palette': 'Remove Palette',
        'tooltip_copy_palette': 'Copy Palette',
        'tooltip_load_palette': 'Load Palette',
        'tooltip_adjust_color': 'Adjust Color',
        
        # File dialogs
        'dialog_select_image': 'Select Image',
        'dialog_save_pgf': 'Save PGF...',
        'dialog_save_as': 'Save As...',
        'dialog_open_pgf': 'Open PGF...',
        'dialog_select_image_recolor': 'Select Image',
        'dialog_save_recolored': 'Save Recolored Image',
        
        # Color selection dialogs
        'harmonies_title': 'Select Color Harmonies',
        'select_harmonies': 'Select color harmonies to display:',
        'custom_harmonies': 'Custom Harmonies:',
        'pick_color_title': 'Pick Color',
        'add_color_title': 'Add Color',
        'edit_color_title': 'Edit Color',
        
        # Color box tooltip
        'tooltip_color_box': 'Left click: Add to palette\nRight click: Set as base color',
        
        # Palette edit buttons
        'sort_by_hue': 'Sort by Hue',
        'sort_by_saturation': 'Sort by Saturation',
        'sort_by_luminance': 'Sort by Luminance',
        'sort_reverse': 'Reverse Order',
        'show_values': 'Show Values',
        
        # Loading/status messages
        'screenshot_label': '**Screenshot**',
        'no_image_label': 'No image',
        'empty_palette': 'Empty Palette',
        'generating_ai': 'Generating AI palettes...',
        
        # Settings dialog sections
        'settings_theme_section': 'Theme Settings',
        
        # Settings options
        'language_label': 'Language:',
        'theme_label': 'Theme:',
        'autosave_enable': 'Enable Auto-save',
        'autosave_interval': 'Auto-save Interval (seconds):',
        'max_colors': 'Max Colors:',
        'filter_background': 'Filter Background (exclude white/black)',
        'window_size': 'Window Size:',
        'recent_files_count': 'Recent Files Count:',
        
        # Image recolor dialog
        'select_palette_label': 'Select Palette:',
        'load_image_btn': 'Load Image',
        'view_original_btn': 'View Original Size',
        'save_btn': 'Save',
        'close_btn': 'Close',
        'preview_label': 'Preview',
        
        # AI settings dialog
        'ai_api_key_label': 'Gemini API Key:',
        'ai_api_help': 'Get your API key from https://aistudio.google.com/app/apikey',
        'ai_colors_per_palette': 'Colors per Palette:',
        'ai_keywords_label': 'Keywords (comma separated):',
        'ai_keywords_example': 'Example: ocean, calm, blue',
        'ai_test_api': 'Test API Key',
        
        # General
        'image_files': 'Image files',
        'all_files': 'All files',
        
        # Dialog titles
        'dialog_settings': 'Settings',
        'dialog_palette_editor': 'Palette Editor',
        'dialog_ai_settings': 'AI Settings',
        'dialog_select_harmonies': 'Select Color Harmonies',
        'dialog_apply_palette': 'Apply Palette',
        'dialog_custom_harmony': 'Custom Color Harmony',
        'dialog_preset_palettes': 'Preset Palettes',
        'dialog_rename_palette': 'Rename Palette',

        # Common
        'unnamed': 'Unnamed',
        'done': 'Done',

        # Module/Dialog errors
        'custom_harmony_module_missing': 'Custom harmony module not found.',
        'custom_harmony_open_failed': 'Failed to open custom harmony: {error}',
        'preset_module_missing': 'Preset palette module not found.',
        'preset_open_failed': 'Failed to open preset palettes: {error}',

        # Preset palettes
        'preset_added_title': 'Palette Added',
        'preset_added_msg': '"{name}" has been added to saved palettes.',
        'preset_pick_search_color': 'Pick a color to search',

        # Custom harmony
        'custom_harmony_select_delete': 'Please select a harmony to delete.',
        'custom_harmony_confirm_delete': 'Are you sure you want to delete?',
        'custom_harmony_name_required': 'Please enter a harmony name.',
        'custom_harmony_color_required': 'Please add at least one color.',
        'custom_harmony_saved': 'Harmony saved.',
        'custom_harmony_hsv_item': '{i}. HSV (H:{h:+.0f}¬∞, S:{s:+.0f}%, V:{v:+.0f}%)',
        'custom_harmony_fixed_item': '{i}. Fixed Color: {hex}',
        
        # Settings window messages
        'settings_saved': 'Settings saved successfully.\nLanguage changes will be applied after restart.',
        'settings_save_failed': 'Failed to save settings.',
        'settings_saved_title': 'Saved',
        'settings_save_failed_title': 'Save Failed',
        
        # AI error messages
        'ai_quota_exceeded': 'API quota exceeded.\nPlease try again later or check your API key.',
        'ai_api_test_success': 'API key is working correctly!',
        'ai_api_test_failed': 'API key test failed: {error}',
        'ai_api_invalid_key': 'Invalid API key.',
        'ai_api_network_error': 'Network error occurred. Please check your internet connection.',
        'ai_generation_failed': 'AI palette generation failed: {error}',
        
        # Palette editor messages
        'palette_editor_title': 'Palette Editor - {name}',
        'color_added': 'Color added.',
        'color_edited': 'Color edited.',
        'select_color_first': 'Please select a color first.',
        
        # Context menu
        'context_rename': 'Rename',
        'context_edit_palette': 'Edit Palette',
        'context_save_palette': 'Save Palette',
        'context_export_txt': 'Export as TXT',
        'context_export_png': 'Export as PNG',
        'context_toggle_view': 'View as RGB',
        
        # Settings dialog
        'settings_language_section': 'Language Settings',
        'settings_autosave_section': 'Auto-save Settings',
        'settings_extraction_section': 'Color Extraction Settings',
        'settings_ui_section': 'UI Settings',
        'settings_autosave_enable': 'Enable auto-save',
        'settings_autosave_interval': 'Auto-save interval (seconds):',
        'settings_max_colors': 'Max colors:',
        'settings_filter_background': 'Filter background colors (exclude white/black)',
        'settings_window_size': 'Window size:',
        'settings_recent_files': 'Recent files:',
        'settings_recent_colors': 'Max recent colors:',
        'button_save': 'Save',
        'button_close': 'Close',
        
        # Image recoloring dialog
        'recolor_select_palette': 'Select Palette:',
        'recolor_load_image': 'Load Image',
        'recolor_view_original': 'View Original Size',
        'recolor_preview': 'Preview',
        'recolor_empty_palette': 'Empty palette',
        
        # Preset palette dialog
        'preset_filter': 'Filter:',
        'preset_all': 'All',
        'preset_search_color': 'Search by Color',
        'preset_reset_filter': 'Reset Filter',
        'preset_count': '{current} / {total} palettes',
        'preset_use': 'Use',
        
        # Color harmony labels
        'base_color_label': 'Base Color',
        'complementary_label': 'Complementary',
        'analogous_label': 'Analogous',
        'triadic_label': 'Triadic',
        'color_box_tooltip': 'Left click: Add to palette\nRight click: Set as base color',
        
        # Recent colors
        'recent_colors_title': 'Recent Colors',
        'recent_colors_clear': 'Clear History',
        'recent_colors_empty': 'No recent colors',
        
        # Palette selection
        'selection_required': 'Selection Required',
        'select_palette_first': 'Please select a saved palette on the right first.',
        'select_palette_to_adjust': 'Please select a palette to adjust.',
        'saved_palette_default_name': 'Saved Palette',
        'palette_numbered': 'Palette {i}',
        'copy_suffix': ' (Copy)',
        'new_palette_numbered': 'New Palette {i}',
        'unknown': 'Unknown',
        'tooltip_palette_color_info': '{hex}\nRGB: {rgb}\nGrayscale: {lum}/255',
        'msg_set_base_color_failed': 'Failed to set base color:\n{error}',

        'color_adjuster_title': 'Color Adjustment',
        'warmth_hint': '(Cool ‚Üê ‚Üí Warm)',
        'label_rgb': 'RGB: {value}',
        'label_hex': 'HEX: {value}',
        'dialog_open_mps': 'Open Palette File',
        'saved_palettes_list': 'Saved Palettes List',
        'browse_other_file': 'Browse Other File',
        'load': 'Load',
        'msg_file_not_found': 'File not found.',
        'ai_module_missing': 'AI recommendation module not found.',

        # ai_color_recommender.py
        'ai_recommender_missing_library': "google-generativeai library is not installed.\nRun '{install_cmd}'.",
        'ai_recommender_init_failed': 'Failed to initialize Gemini model: {error}',
        'ai_recommender_api_key_not_set': 'API key is not set.',
        'ai_recommender_generation_failed': 'Failed to generate AI palettes: {error}',
        'ai_recommender_test_prompt': "Say 'OK' if you can read this.",
        'ai_recommender_test_success': 'API key works correctly.',
        'ai_recommender_test_no_response': 'No response received.',
        'ai_recommender_test_failed': 'API key test failed: {error}',
        'ai_recommender_prompt_with_keywords': """Create {num_palettes} color palettes ({num_colors} colors each) based on: {keywords}
    Format: PaletteName: #HEX,#HEX,#HEX,#HEX,#HEX
    Example: Ocean Breeze: #0077BE,#00A8E8,#48CAE4,#90E0EF,#ADE8F4
    Give each palette a creative 2-3 word name. Output only palette lines.""",
        'ai_recommender_prompt_without_keywords': """Create {num_palettes} diverse color palettes ({num_colors} colors each).
    Format: PaletteName: #HEX,#HEX,#HEX,#HEX,#HEX
    Example: Sunset Warm: #FF6B35,#F7931E,#FDC830,#F37335,#C0392B
    Give each palette a creative 2-3 word name. Output only palette lines.""",
        'ai_settings_open_failed': 'Failed to open AI settings: {error}',
        
        # Accessibility checker
        'accessibility_title': 'Accessibility Check',
        'accessibility_check': 'Check Contrast',
        'accessibility_wcag_aa': 'WCAG AA Standard',
        'accessibility_wcag_aaa': 'WCAG AAA Standard',
        'accessibility_ratio': 'Contrast ratio: {ratio}:1',
        'accessibility_pass': 'Pass',
        'accessibility_fail': 'Fail',
        
        # Gradient generator
        'gradient_title': 'Generate Gradient',
        'gradient_steps': 'Number of steps:',
        'gradient_generate': 'Generate',
        'gradient_color_from': 'From Color',
        'gradient_color_to': 'To Color',

        # Custom harmony editor
        'saved_harmonies': 'Saved Harmonies',
        'delete_harmony': 'Delete',
        'color_list': 'Color List',
        'colors': 'Colors',
        'fixed_color': 'Fixed Color',
        'add_hsv_color': 'Add HSV Color',
        'edit_hsv_color': 'Edit HSV Color',
        'add_fixed_color': 'Add Fixed Color',
        'extract_from_image': 'Extract from Image',
        'msg_colors_extracted': '{count} colors extracted.',
        'edit': 'Edit',
        'move_up': 'Move Up',
        'move_down': 'Move Down',
        'new_harmony': 'New Harmony',
        'harmony_name': 'Harmony Name',
        'edit_color': 'Edit Color',
        'preview': 'Preview',
        
        # CustomTkinter UI additional keys
        'tab_palette': 'Palette',
        'tab_recolor': 'Image Recolor',
        'tab_custom_harmony': 'Custom Harmony',
        'color_settings': 'Color Settings',
        'source_type': 'Source Type',
        'selected_color': 'Selected Color',
        'generated_palette': 'Generated Palette',
        'view_rgb': 'View as HEX',
        'view_value': 'View as Value',
        'no_recent_files': 'No recent files',
        'my_palette_file': 'My Palette File',
        'text_file': 'Text File',
        'png_image': 'PNG Image',
        'export_title': 'Export',
        'save_prompt_title': 'Save Confirmation',
        'msg_save_changes_prompt': 'Do you want to save changes?',
        'saved_title': 'Saved',
        'loaded_title': 'Loaded',
        'msg_workspace_saved': 'Workspace saved:\n{path}',
        'msg_workspace_loaded': 'Workspace loaded:\n{path}',
        'msg_no_save_path': 'Save path not specified.',
        'msg_file_not_found_path': 'File not found:\n{path}',
        'reset_settings_title': 'Reset Settings',
        'msg_reset_settings_confirm': 'Reset all settings to default values?',
        'reset_done_title': 'Reset Complete',
        'msg_settings_reset_done': 'Settings have been reset to defaults.',
        'ai_palette_name': 'AI Palette {i}',
        'ai_generating_title': 'AI Generating',
        'ai_error_title': 'AI Error',
        'button_cancel': 'Cancel',
        'cancel': 'Cancel',
        'empty_palette_msg': 'Click a color to add',
        'colors_count': '{count} colors',
        'confirm': 'Confirm',
        'delete': 'Delete',
        'msg_no_preview': 'No preview available. Apply palette first.',
        'select_harmony_prompt': 'Select a harmony to edit',
    }
    
    def __init__(self, language='ko'):
        """
        Args:
            language: 'ko' (Korean) or 'en' (English)
        """
        self.language = language
        self.texts = self.KOREAN if language == 'ko' else self.ENGLISH
    
    def get(self, key, default=None):
        """Get text"""
        return self.texts.get(key, default or key)
    
    def set_language(self, language):
        """Change language"""
        self.language = language
        self.texts = self.KOREAN if language == 'ko' else self.ENGLISH
    
    def get_current_language(self):
        """Return current language"""
        return self.language
</file>

<file path="main.py">
"""
Color Palette Generator - Modern CustomTkinter UI
A SaaS-style dashboard for color palette creation and management.

Design System:
- Theme: Dark Mode (Anthracite #1E1E1E)
- Accent: Soft Blue (#3B82F6)
- Corner Radius: 10px
- Font: Segoe UI / SF Pro Display style
"""

from PIL import Image, ImageTk, ImageGrab, ImageDraw
import customtkinter as ctk
import tkinter as tk
from tkinter import filedialog, messagebox, colorchooser
import os
import tempfile
import logging
import hashlib
import colorsys
import base64
from cryptography.fernet import Fernet

# Import new modules
from color_generator import ColorPaletteGenerator
from file_handler import FileHandler
from config_manager import ConfigManager
from image_recolorer import ImageRecolorer
from language_manager import LanguageManager

# Import embedded icons (window icon + UI icons)
try:
    from embedded_icons import (
        load_icon,
        EMBEDDED_ICON_DATA,
        CAMERA_ICON_DATA, COPY_ICON_DATA, DELETE_ICON_DATA,
        DICE_ICON_DATA, FOLDER_ICON_DATA, IMAGE_ICON_DATA,
        LIGHTNING_ICON_DATA, NEW_FILE_ICON_DATA, PALETTE_ICON_DATA,
        SETTINGS_ICON_DATA, SPARKLE_ICON_DATA, TOOLS_ICON_DATA,
        ZOOM_ICON_DATA,
    )
    UI_ICONS_AVAILABLE = True
except ImportError:
    EMBEDDED_ICON_DATA = None
    UI_ICONS_AVAILABLE = False

# Import color adjuster if available
try:
    from color_adjuster import apply_contrast, apply_warmth
    COLOR_ADJUSTER_AVAILABLE = True
except Exception:
    COLOR_ADJUSTER_AVAILABLE = False
    apply_contrast = None
    apply_warmth = None

# ============== Design System Constants ==============
COLORS = {
    'bg_dark': '#1E1E1E',          # Anthracite - Main background
    'bg_secondary': '#2D2D2D',     # Secondary background
    'bg_card': '#363636',          # Card background
    'bg_hover': '#404040',         # Hover state
    'accent': '#3B82F6',           # Soft Blue - Primary accent
    'accent_hover': '#2563EB',     # Accent hover
    'accent_light': '#60A5FA',     # Light accent
    'text_primary': '#FFFFFF',     # Primary text
    'text_secondary': '#A1A1AA',   # Secondary text
    'text_muted': '#71717A',       # Muted text
    'border': '#404040',           # Border color
    'success': '#22C55E',          # Success green
    'warning': '#F59E0B',          # Warning amber
    'error': '#EF4444',            # Error red
}

CORNER_RADIUS = 10
PADDING = 10
FONT_FAMILY = "Segoe UI"

# Configure CustomTkinter
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# Global icon path for all windows
_ICON_PATH = None


def get_icon_path():
    """Get or create icon path from embedded data"""
    global _ICON_PATH
    
    if _ICON_PATH and os.path.exists(_ICON_PATH):
        return _ICON_PATH
    
    if EMBEDDED_ICON_DATA:
        try:
            icon_data = base64.b64decode(EMBEDDED_ICON_DATA.strip())
            temp_icon = tempfile.NamedTemporaryFile(delete=False, suffix='.ico')
            temp_icon.write(icon_data)
            temp_icon.close()
            _ICON_PATH = temp_icon.name
            return _ICON_PATH
        except Exception:
            pass
    
    icon_path = os.path.join(os.path.dirname(__file__), 'icon.ico')
    if os.path.exists(icon_path):
        _ICON_PATH = icon_path
        return _ICON_PATH
    
    return None


def set_window_icon(window):
    """Apply icon to any window (main or Toplevel)"""
    try:
        icon_path = get_icon_path()
        if icon_path:
            window.iconbitmap(icon_path)
    except Exception:
        pass


class ModernCard(ctk.CTkFrame):
    """A modern card component with subtle shadow effect"""
    def __init__(self, master, title=None, **kwargs):
        super().__init__(
            master, 
            corner_radius=CORNER_RADIUS,
            fg_color=COLORS['bg_card'],
            border_width=1,
            border_color=COLORS['border'],
            **kwargs
        )
        
        if title:
            self.title_label = ctk.CTkLabel(
                self,
                text=title,
                font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
                text_color=COLORS['text_primary']
            )
            self.title_label.pack(anchor="w", padx=15, pady=(15, 10))


class ModernButton(ctk.CTkButton):
    """Styled button with consistent design"""
    def __init__(self, master, text="", **kwargs):
        default_kwargs = {
            'corner_radius': CORNER_RADIUS,
            'fg_color': COLORS['accent'],
            'hover_color': COLORS['accent_hover'],
            'text_color': COLORS['text_primary'],
            'font': ctk.CTkFont(family=FONT_FAMILY, size=12),
            'height': 36
        }
        default_kwargs.update(kwargs)
        super().__init__(master, text=text, **default_kwargs)


class ModernSecondaryButton(ctk.CTkButton):
    """Secondary styled button"""
    def __init__(self, master, text="", **kwargs):
        default_kwargs = {
            'corner_radius': CORNER_RADIUS,
            'fg_color': COLORS['bg_secondary'],
            'hover_color': COLORS['bg_hover'],
            'text_color': COLORS['text_primary'],
            'border_width': 1,
            'border_color': COLORS['border'],
            'font': ctk.CTkFont(family=FONT_FAMILY, size=12),
            'height': 36
        }
        default_kwargs.update(kwargs)
        super().__init__(master, text=text, **default_kwargs)


class ModernIconButton(ctk.CTkButton):
    """Icon-only button for toolbar actions"""
    def __init__(self, master, text="", **kwargs):
        default_kwargs = {
            'corner_radius': 8,
            'fg_color': 'transparent',
            'hover_color': COLORS['bg_hover'],
            'text_color': COLORS['text_primary'],
            'font': ctk.CTkFont(size=16),
            'width': 36,
            'height': 36
        }
        default_kwargs.update(kwargs)
        super().__init__(master, text=text, **default_kwargs)


class ColorSwatch(ctk.CTkFrame):
    """A clickable color swatch with hover effect"""
    def __init__(self, master, color="#FFFFFF", size=40, command=None, **kwargs):
        super().__init__(
            master,
            width=size,
            height=size,
            corner_radius=6,
            fg_color=color,
            **kwargs
        )
        self.color = color
        self.command = command
        self.size = size
        
        # Prevent size changes
        self.pack_propagate(False)
        self.grid_propagate(False)
        
        # Bind click event
        if command:
            self.bind("<Button-1>", lambda e: command())
            self.configure(cursor="hand2")


class PaletteApp(ctk.CTk):
    """Main Application - Modern SaaS Dashboard Style"""
    
    def __init__(self):
        super().__init__()
        
        # Set window icon
        set_window_icon(self)
        
        # Initialize managers
        self.file_handler = FileHandler()
        self.config_manager = ConfigManager(self.file_handler)
        
        # Initialize language manager
        current_lang = self.config_manager.get('language', 'ko')
        self.lang = LanguageManager(current_lang)
        
        # Window configuration
        window_width = self.config_manager.get('window_width', 1100)
        window_height = self.config_manager.get('window_height', 700)
        self.geometry(f"{window_width}x{window_height}")
        self.minsize(900, 600)
        
        # Configure window background
        self.configure(fg_color=COLORS['bg_dark'])
        
        # Initialize core components
        self.generator = ColorPaletteGenerator()
        self.image_path = None
        self._temp_screenshot = None
        
        self.ai_recommender = None
        self.ai_palettes = []
        self.ai_palette_offset = 0
        
        self.selected_schemes = ['complementary', 'analogous', 'triadic', 'monochromatic']
        
        self.current_file = None
        self.is_modified = False
        
        self.auto_save_enabled = self.config_manager.get('auto_save_enabled', True)
        self.auto_save_interval = self.config_manager.get('auto_save_interval', 300) * 1000
        self.auto_save_timer = None
        
        # Recent colors storage
        self.recent_colors = self.config_manager.get('recent_colors', []) or []
        try:
            self.max_recent_colors = int(self.config_manager.get('max_recent_colors', 50))
        except Exception:
            self.max_recent_colors = 50
        self.max_recent_colors = max(1, min(100, self.max_recent_colors))

        if len(self.recent_colors) > self.max_recent_colors:
            self.recent_colors = self.recent_colors[:self.max_recent_colors]
            self.config_manager.set('recent_colors', self.recent_colors)
            self.config_manager.save_config()
        
        # Global tooltip tracker to prevent ghosting
        self.active_tooltips = []
        
        # Load UI icons
        self._icons = {}
        self._load_ui_icons()
        
        self.setup_logging()
        self.log_action("Application started")
        
        # Initialize preset palettes if not exists
        self._init_preset_palettes_async()
        
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        self.bind_shortcuts()
        self.setup_drag_drop()

        # Create UI
        self.create_widgets()
        
        self.update_title()
        
        if self.auto_save_enabled:
            self.start_auto_save()
    
    def _load_ui_icons(self):
        """Load all UI icons from embedded data into CTkImage objects"""
        if not UI_ICONS_AVAILABLE:
            return
        try:
            icon_map = {
                'palette': PALETTE_ICON_DATA,
                'folder': FOLDER_ICON_DATA,
                'settings': SETTINGS_ICON_DATA,
                'tools': TOOLS_ICON_DATA,
                'camera': CAMERA_ICON_DATA,
                'zoom': ZOOM_ICON_DATA,
                'sparkle': SPARKLE_ICON_DATA,
                'dice': DICE_ICON_DATA,
                'lightning': LIGHTNING_ICON_DATA,
                'delete': DELETE_ICON_DATA,
                'new_file': NEW_FILE_ICON_DATA,
                'copy': COPY_ICON_DATA,
                'image': IMAGE_ICON_DATA,
            }
            for name, data in icon_map.items():
                try:
                    pil_img = load_icon(data, size=(20, 20))
                    self._icons[name] = ctk.CTkImage(
                        light_image=pil_img, dark_image=pil_img, size=(20, 20)
                    )
                except Exception:
                    pass
            # Larger icons for bigger buttons
            for name, data in [('sparkle_lg', SPARKLE_ICON_DATA)]:
                try:
                    pil_img = load_icon(data.replace('sparkle_lg', 'sparkle') if 'sparkle_lg' in str(data) else data, size=(24, 24))
                    self._icons[name] = ctk.CTkImage(
                        light_image=pil_img, dark_image=pil_img, size=(24, 24)
                    )
                except Exception:
                    pass
        except Exception:
            pass
    
    def _get_icon(self, name):
        """Get a loaded CTkImage icon by name, or None if unavailable"""
        return self._icons.get(name)

    def create_widgets(self):
        """Create the main UI layout with modern dashboard design"""
        
        # ============== Header Section ==============
        self.create_header()
        
        # ============== Main Content Area ==============
        self.main_container = ctk.CTkFrame(self, fg_color="transparent")
        self.main_container.pack(fill="both", expand=True, padx=15, pady=(0, 15))
        
        # Create TabView for main content
        self.tabview = ctk.CTkTabview(
            self.main_container,
            corner_radius=CORNER_RADIUS,
            fg_color=COLORS['bg_secondary'],
            segmented_button_fg_color=COLORS['bg_card'],
            segmented_button_selected_color=COLORS['accent'],
            segmented_button_unselected_color=COLORS['bg_card'],
            text_color=COLORS['text_primary'],
        )
        self.tabview.pack(fill="both", expand=True)
        
        # Add tabs with language support
        self.tab_palette = self.tabview.add(self.lang.get('tab_palette'))
        self.tab_recolor = self.tabview.add(self.lang.get('tab_recolor'))
        self.tab_custom = self.tabview.add(self.lang.get('tab_custom_harmony'))
        
        # Create content for each tab
        self.create_palette_tab()
        self.create_recolor_tab()
        self.create_custom_harmony_tab()
        
        # Initialize saved palettes
        self.saved_palettes = []
        self._saved_counter = 0
        self._saved_selected = None
        
        # Create initial saved palette
        name = self.lang.get('new_palette_numbered').format(i=self._saved_counter + 1)
        self._saved_counter += 1
        entry = {'name': name, 'colors': []}
        self.saved_palettes.append(entry)
        if self.saved_palettes:
            self._saved_selected = 0
            self.render_saved_list()
        
        # Initial generate
        self.on_source_change()
        self.generate()
    
    def create_header(self):
        """Create the modern app header with navigation"""
        self.header = ctk.CTkFrame(
            self,
            height=60,
            corner_radius=0,
            fg_color=COLORS['bg_secondary']
        )
        self.header.pack(fill="x", padx=0, pady=0)
        self.header.pack_propagate(False)
        
        # Left section: Logo and title
        left_section = ctk.CTkFrame(self.header, fg_color="transparent")
        left_section.pack(side="left", padx=20, fill="y")
        
        # App title
        title_label = ctk.CTkLabel(
            left_section,
            text=" Color Palette Generator",
            image=self._get_icon('palette'),
            compound='left',
            font=ctk.CTkFont(family=FONT_FAMILY, size=18, weight="bold"),
            text_color=COLORS['text_primary']
        )
        title_label.pack(side="left", pady=15)
        
        # Right section: Action buttons
        right_section = ctk.CTkFrame(self.header, fg_color="transparent")
        right_section.pack(side="right", padx=20, fill="y")
        
        # File operations dropdown
        self.file_menu_btn = ModernSecondaryButton(
            right_section,
            text=f" {self.lang.get('menu_file')}",
            image=self._get_icon('folder'),
            compound='left',
            width=100,
            command=self.show_file_menu
        )
        self.file_menu_btn.pack(side="left", padx=5, pady=12)
        
        # Settings button
        self.settings_btn = ModernSecondaryButton(
            right_section,
            text=f" {self.lang.get('menu_settings')}",
            image=self._get_icon('settings'),
            compound='left',
            width=100,
            command=self.open_settings
        )
        self.settings_btn.pack(side="left", padx=5, pady=12)
        
        # Tools button
        self.tools_btn = ModernSecondaryButton(
            right_section,
            text=f" {self.lang.get('tools')}",
            image=self._get_icon('tools'),
            compound='left',
            width=100,
            command=self.show_tools_menu
        )
        self.tools_btn.pack(side="left", padx=5, pady=12)
    
    def create_palette_tab(self):
        """Create the main palette generation tab with sidebar layout"""
        
        # Main container with two columns
        content_frame = ctk.CTkFrame(self.tab_palette, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Configure grid
        content_frame.grid_columnconfigure(0, weight=1, minsize=280)  # Left sidebar
        content_frame.grid_columnconfigure(1, weight=3)  # Main content
        content_frame.grid_rowconfigure(0, weight=1)
        
        # ============== Left Sidebar: Color Settings ==============
        self.create_sidebar(content_frame)
        
        # ============== Right Main Content: Results ==============
        self.create_main_content(content_frame)
    
    def create_sidebar(self, parent):
        """Create the left sidebar with color settings"""
        sidebar_container = ctk.CTkFrame(
            parent,
            corner_radius=CORNER_RADIUS,
            fg_color=COLORS['bg_card'],
            border_width=1,
            border_color=COLORS['border']
        )
        sidebar_container.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=0)
        
        # Sidebar title (fixed at top)
        sidebar_title = ctk.CTkLabel(
            sidebar_container,
            text=self.lang.get('color_settings'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        )
        sidebar_title.pack(anchor="w", padx=15, pady=(15, 10))
        
        # Scrollable content area
        sidebar = ctk.CTkScrollableFrame(
            sidebar_container,
            fg_color="transparent",
            scrollbar_button_color=COLORS['text_muted'],
            scrollbar_button_hover_color=COLORS['text_secondary']
        )
        sidebar.pack(fill="both", expand=True, padx=5, pady=(0, 5))
        
        # Source type selection
        source_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
        source_frame.pack(fill="x", padx=15, pady=5)
        
        source_label = ctk.CTkLabel(
            source_frame,
            text=self.lang.get('source_type'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12),
            text_color=COLORS['text_secondary']
        )
        source_label.pack(anchor="w")
        
        self.source_type = ctk.StringVar(value='hex')
        
        # Radio buttons for source type
        radio_frame = ctk.CTkFrame(source_frame, fg_color="transparent")
        radio_frame.pack(fill="x", pady=5)
        
        self.rb_hex = ctk.CTkRadioButton(
            radio_frame,
            text=self.lang.get('pick_color'),
            variable=self.source_type,
            value='hex',
            command=self.on_source_change,
            fg_color=COLORS['accent'],
            hover_color=COLORS['accent_hover'],
            text_color=COLORS['text_primary']
        )
        self.rb_hex.pack(anchor="w", pady=2)
        
        self.rb_img = ctk.CTkRadioButton(
            radio_frame,
            text=self.lang.get('from_image'),
            variable=self.source_type,
            value='image',
            command=self.on_source_change,
            fg_color=COLORS['accent'],
            hover_color=COLORS['accent_hover'],
            text_color=COLORS['text_primary']
        )
        self.rb_img.pack(anchor="w", pady=2)
        
        self.rb_ai = ctk.CTkRadioButton(
            radio_frame,
            text=self.lang.get('ai_palette'),
            variable=self.source_type,
            value='ai',
            command=self.on_source_change,
            fg_color=COLORS['accent'],
            hover_color=COLORS['accent_hover'],
            text_color=COLORS['text_primary']
        )
        self.rb_ai.pack(anchor="w", pady=2)
        
        # Separator
        sep1 = ctk.CTkFrame(sidebar, height=1, fg_color=COLORS['border'])
        sep1.pack(fill="x", padx=15, pady=15)
        
        # Color picker section
        color_section = ctk.CTkFrame(sidebar, fg_color="transparent")
        color_section.pack(fill="x", padx=15, pady=5)
        
        color_label = ctk.CTkLabel(
            color_section,
            text=self.lang.get('selected_color'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12),
            text_color=COLORS['text_secondary']
        )
        color_label.pack(anchor="w")
        
        # Color swatch and picker
        self.hex_entry = ctk.StringVar(value="#3498db")
        
        swatch_row = ctk.CTkFrame(color_section, fg_color="transparent")
        swatch_row.pack(fill="x", pady=10)
        
        # Color swatch display (using Canvas for color display)
        self.color_swatch_frame = ctk.CTkFrame(
            swatch_row,
            width=80,
            height=50,
            corner_radius=8,
            fg_color="#3498db"
        )
        self.color_swatch_frame.pack(side="left")
        self.color_swatch_frame.pack_propagate(False)
        
        # Color info
        self.color_info_frame = ctk.CTkFrame(swatch_row, fg_color="transparent")
        self.color_info_frame.pack(side="left", padx=15, fill="y")
        
        self.lbl_hex_value = ctk.CTkLabel(
            self.color_info_frame,
            text="#3498db",
            font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
            text_color=COLORS['text_primary']
        )
        self.lbl_hex_value.pack(anchor="w")
        
        self.lbl_rgb_value = ctk.CTkLabel(
            self.color_info_frame,
            text="RGB(52, 152, 219)",
            font=ctk.CTkFont(family=FONT_FAMILY, size=11),
            text_color=COLORS['text_secondary']
        )
        self.lbl_rgb_value.pack(anchor="w")
        
        # Color picker button
        self.btn_color_picker = ModernButton(
            color_section,
            text=f" {self.lang.get('pick_color')}",
            image=self._get_icon('palette'),
            compound='left',
            command=self.open_color_picker
        )
        self.btn_color_picker.pack(fill="x", pady=5)
        
        # Image selection
        self.btn_select_img = ModernSecondaryButton(
            color_section,
            text=f" {self.lang.get('select_image')}",
            image=self._get_icon('camera'),
            compound='left',
            command=self.select_image
        )
        self.btn_select_img.pack(fill="x", pady=5)
        
        # Screen picker
        self.btn_screen_pick = ModernSecondaryButton(
            color_section,
            text=f" {self.lang.get('extract_from_screen')}",
            image=self._get_icon('zoom'),
            compound='left',
            command=self.start_screen_picker
        )
        self.btn_screen_pick.pack(fill="x", pady=5)
        
        # Image info label
        self.lbl_image = ctk.CTkLabel(
            color_section,
            text=self.lang.get('no_file_selected'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=11),
            text_color=COLORS['text_muted']
        )
        self.lbl_image.pack(anchor="w", pady=5)
        
        # Image thumbnail
        self.img_thumbnail_label = ctk.CTkLabel(color_section, text="")
        self.img_thumbnail_label.pack(pady=5)
        
        # Separator
        sep2 = ctk.CTkFrame(sidebar, height=1, fg_color=COLORS['border'])
        sep2.pack(fill="x", padx=15, pady=15)
        
        # Action buttons
        action_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
        action_frame.pack(fill="x", padx=15, pady=5)
        
        self.btn_generate = ModernButton(
            action_frame,
            text=f" {self.lang.get('generate')}",
            image=self._get_icon('sparkle'),
            compound='left',
            command=self.generate,
            height=48,
            font=ctk.CTkFont(family=FONT_FAMILY, size=15, weight="bold")
        )
        self.btn_generate.pack(fill="x", pady=5)
        
        self.btn_random = ModernSecondaryButton(
            action_frame,
            text=f" {self.lang.get('random_color')}",
            image=self._get_icon('dice'),
            compound='left',
            command=self.generate_random
        )
        self.btn_random.pack(fill="x", pady=5)
        
        self.btn_harmony = ModernSecondaryButton(
            action_frame,
            text=f" {self.lang.get('harmony_options')}",
            image=self._get_icon('lightning'),
            compound='left',
            command=self.open_harmony_selector
        )
        self.btn_harmony.pack(fill="x", pady=5)
        
        # Recent colors section at bottom
        sep3 = ctk.CTkFrame(sidebar, height=1, fg_color=COLORS['border'])
        sep3.pack(fill="x", padx=15, pady=15)
        
        recent_header = ctk.CTkFrame(sidebar, fg_color="transparent")
        recent_header.pack(fill="x", padx=15)
        
        recent_label = ctk.CTkLabel(
            recent_header,
            text=self.lang.get('recent_colors_title'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
            text_color=COLORS['text_primary']
        )
        recent_label.pack(side="left")
        
        btn_clear_recent = ModernIconButton(
            recent_header,
            text="",
            image=self._get_icon('delete'),
            command=self.clear_recent_colors,
            width=30,
            height=30
        )
        btn_clear_recent.pack(side="right")
        
        # Recent colors grid
        self.recent_colors_frame = ctk.CTkScrollableFrame(
            sidebar,
            height=80,
            fg_color="transparent",
            orientation="horizontal"
        )
        self.recent_colors_frame.pack(fill="x", padx=15, pady=10)
        
        self.update_recent_colors_display()
    
    def create_main_content(self, parent):
        """Create the main content area with palette results and saved palettes"""
        main_content = ctk.CTkFrame(parent, fg_color="transparent")
        main_content.grid(row=0, column=1, sticky="nsew")
        
        # Configure grid for main content
        main_content.grid_columnconfigure(0, weight=2)  # Palette display
        main_content.grid_columnconfigure(1, weight=1)  # Saved palettes
        main_content.grid_rowconfigure(0, weight=1)
        
        # ============== Palette Display (Left) ==============
        self.palette_card = ModernCard(main_content, title=self.lang.get('generated_palette'))
        self.palette_card.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=0)
        
        # Scrollable frame for palette colors
        self.palette_scroll = ctk.CTkScrollableFrame(
            self.palette_card,
            fg_color="transparent"
        )
        self.palette_scroll.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Placeholder for palette_inner (for compatibility with existing code)
        self.palette_inner = self.palette_scroll
        
        # ============== Saved Palettes (Right) ==============
        self.saved_card = ModernCard(main_content, title=self.lang.get('saved_palettes'))
        self.saved_card.grid(row=0, column=1, sticky="nsew", pady=0)
        
        # Saved palettes toolbar
        saved_toolbar = ctk.CTkFrame(self.saved_card, fg_color="transparent")
        saved_toolbar.pack(fill="x", padx=15, pady=5)
        
        # Icon buttons for palette management
        self.btn_add = ModernIconButton(saved_toolbar, text="", image=self._get_icon('new_file'), command=self.add_saved_palette)
        self.btn_add.pack(side="left", padx=2)
        self.create_tooltip(self.btn_add, self.lang.get('tooltip_add_palette'))
        
        self.btn_delete = ModernIconButton(saved_toolbar, text="", image=self._get_icon('delete'), command=self.remove_saved_palette)
        self.btn_delete.pack(side="left", padx=2)
        self.create_tooltip(self.btn_delete, self.lang.get('tooltip_delete_palette'))
        
        self.btn_copy = ModernIconButton(saved_toolbar, text="", image=self._get_icon('copy'), command=self.copy_palette)
        self.btn_copy.pack(side="left", padx=2)
        self.create_tooltip(self.btn_copy, self.lang.get('tooltip_copy_palette'))
        
        self.btn_load = ModernIconButton(saved_toolbar, text="", image=self._get_icon('folder'), command=self.load_palette)
        self.btn_load.pack(side="left", padx=2)
        self.create_tooltip(self.btn_load, self.lang.get('tooltip_load_palette'))
        
        if COLOR_ADJUSTER_AVAILABLE:
            self.btn_adjust = ModernIconButton(saved_toolbar, text="", image=self._get_icon('palette'), command=self.open_color_adjuster)
            self.btn_adjust.pack(side="left", padx=2)
            self.create_tooltip(self.btn_adjust, self.lang.get('tooltip_adjust_color'))
        
        # Scrollable list of saved palettes
        self.saved_scroll = ctk.CTkScrollableFrame(
            self.saved_card,
            fg_color="transparent"
        )
        self.saved_scroll.pack(fill="both", expand=True, padx=10, pady=10)
        
        # For compatibility
        self.saved_list_container = self.saved_scroll
    
    def create_recolor_tab(self):
        """Create the image recoloring tab"""
        # Placeholder - will be filled when tab is selected
        placeholder = ctk.CTkLabel(
            self.tab_recolor,
            text=f" {self.lang.get('apply_palette_to_image')}",
            image=self._get_icon('image'),
            compound='left',
            font=ctk.CTkFont(family=FONT_FAMILY, size=16)
        )
        placeholder.pack(expand=True)
        
        open_btn = ModernButton(
            self.tab_recolor,
            text=self.lang.get('apply_palette_to_image'),
            command=self.apply_palette_to_image
        )
        open_btn.pack(pady=20)
    
    def create_custom_harmony_tab(self):
        """Create the custom harmony editor tab"""
        placeholder = ctk.CTkLabel(
            self.tab_custom,
            text=f" {self.lang.get('custom_color_harmonies')}",
            image=self._get_icon('settings'),
            compound='left',
            font=ctk.CTkFont(family=FONT_FAMILY, size=16)
        )
        placeholder.pack(expand=True)
        
        open_btn = ModernButton(
            self.tab_custom,
            text=self.lang.get('custom_color_harmonies'),
            command=self.open_custom_harmony
        )
        open_btn.pack(pady=20)

    # ============== Color Swatch Update ==============
    def _update_color_swatch(self, hex_color):
        """Update the color swatch display"""
        try:
            self.color_swatch_frame.configure(fg_color=hex_color)
            self.lbl_hex_value.configure(text=hex_color.upper())
            
            rgb = self.generator.hex_to_rgb(hex_color)
            self.lbl_rgb_value.configure(text=f"RGB({rgb[0]}, {rgb[1]}, {rgb[2]})")
        except Exception:
            pass
    
    # ============== Recent Colors ==============
    def add_to_recent_colors(self, hex_color):
        """Add a color to recent colors history"""
        hex_color = hex_color.upper()
        
        if hex_color in self.recent_colors:
            self.recent_colors.remove(hex_color)
        
        self.recent_colors.insert(0, hex_color)
        self.recent_colors = self.recent_colors[:self.max_recent_colors]
        
        self.config_manager.set('recent_colors', self.recent_colors)
        self.config_manager.save_config()
        
        self.update_recent_colors_display()
    
    def update_recent_colors_display(self):
        """Update the recent colors display panel"""
        # Clear existing widgets
        for widget in self.recent_colors_frame.winfo_children():
            widget.destroy()
        
        if not self.recent_colors:
            empty_label = ctk.CTkLabel(
                self.recent_colors_frame,
                text=self.lang.get('recent_colors_empty'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=10),
                text_color=COLORS['text_muted']
            )
            empty_label.pack(side="left", padx=5)
            return
        
        for hex_color in self.recent_colors[:20]:  # Show max 20
            swatch = ColorSwatch(
                self.recent_colors_frame,
                color=hex_color,
                size=32,
                command=lambda c=hex_color: self._use_color(c)
            )
            swatch.pack(side="left", padx=2, pady=2)
    
    def _use_color(self, hex_color):
        """Use a color from recent colors"""
        self.hex_entry.set(hex_color)
        self._update_color_swatch(hex_color)
        self.log_action(f"Used color: {hex_color}")
    
    def clear_recent_colors(self):
        """Clear recent colors history"""
        if not self.recent_colors:
            return
        
        self.recent_colors = []
        self.config_manager.set('recent_colors', [])
        self.config_manager.save_config()
        self.update_recent_colors_display()
        self.log_action("Cleared recent colors history")

    # ============== Source Type Change ==============
    def on_source_change(self):
        """Handle source type radio button changes"""
        mode = self.source_type.get()
        
        if mode == 'hex':
            self.btn_color_picker.configure(state="normal")
            self.btn_select_img.configure(state="disabled")
        elif mode == 'image':
            self.btn_color_picker.configure(state="disabled")
            self.btn_select_img.configure(state="normal")
        elif mode == 'ai':
            self.btn_color_picker.configure(state="disabled")
            self.btn_select_img.configure(state="disabled")

    # ============== Color Picker ==============
    def open_color_picker(self):
        """Open color chooser dialog"""
        current_color = self.hex_entry.get()
        try:
            color_result = colorchooser.askcolor(color=current_color, title=self.lang.get('pick_color_title'))
            if color_result[1]:
                hex_color = color_result[1]
                self.hex_entry.set(hex_color)
                self._update_color_swatch(hex_color)
                self.add_to_recent_colors(hex_color)
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('msg_color_picker_failed').format(error=str(e)))

    # ============== Image Selection ==============
    def select_image(self):
        """Select image with validation"""
        if getattr(self, '_temp_screenshot', None):
            try:
                os.unlink(self._temp_screenshot)
            except Exception:
                pass
            self._temp_screenshot = None

        path = filedialog.askopenfilename(
            title=self.lang.get('dialog_select_image'),
            filetypes=[
                (self.lang.get('image_files'), "*.png;*.jpg;*.jpeg;*.bmp;*.gif"),
                (self.lang.get('all_files'), "*.*"),
            ],
        )
        if not path:
            return
        
        try:
            if not os.path.exists(path):
                messagebox.showerror(self.lang.get('error'), self.lang.get('msg_file_not_found'))
                return
            
            file_size = os.path.getsize(path)
            if file_size > 50 * 1024 * 1024:
                response = messagebox.askyesno(
                    self.lang.get('msg_large_file_title'),
                    self.lang.get('msg_large_file_prompt').format(size_mb=file_size // (1024 * 1024)),
                )
                if not response:
                    return
            
            self.image_path = path
            self.log_action(f"Selected image: {os.path.basename(path)}")
            
            name = os.path.basename(path)
            max_len = 20
            if len(name) > max_len:
                name = name[:max_len-3] + "..."
            self.lbl_image.configure(text=name)
            
            # Create thumbnail
            try:
                img = Image.open(path)
                img.thumbnail((48, 48), Image.Resampling.LANCZOS)
                photo = ctk.CTkImage(light_image=img, dark_image=img, size=(48, 48))
                self.img_thumbnail_label.configure(image=photo, text="")
                self.img_thumbnail = photo
                img.close()
            except Exception as e:
                self.log_action(f"Thumbnail creation failed: {str(e)}")
                self.img_thumbnail_label.configure(image=self._get_icon('camera'), text="")
            
            self.extracted_colors = []
            
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('msg_image_load_failed').format(error=str(e)))
            self.log_action(f"Image selection failed: {str(e)}")

    # ============== Screen Picker ==============
    def start_screen_picker(self):
        """Begin screen color picker"""
        try:
            try:
                self._prev_alpha = self.attributes('-alpha')
            except Exception:
                self._prev_alpha = 1.0
            
            try:
                self.attributes('-alpha', 0.0)
                self.update()
                self._did_withdraw = False
            except Exception:
                try:
                    self.withdraw()
                    self._did_withdraw = True
                except Exception:
                    self._did_withdraw = False

            self.after(120, self._capture_and_show_picker)
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('msg_screen_picker_failed').format(error=str(e)))

    def _capture_and_show_picker(self):
        """Capture screen and show color picker overlay"""
        try:
            screen = ImageGrab.grab(all_screens=True)
        except TypeError:
            try:
                screen = ImageGrab.grab()
            except Exception as e:
                self._restore_window()
                messagebox.showerror(self.lang.get('error'), self.lang.get('msg_capture_failed').format(error=str(e)))
                return
        except Exception as e:
            self._restore_window()
            messagebox.showerror(self.lang.get('error'), self.lang.get('msg_capture_failed').format(error=str(e)))
            return

        self._screen_image = screen
        img_w, img_h = screen.size

        x0 = 0
        y0 = 0
        width = img_w
        height = img_h
        
        try:
            if os.name == 'nt':
                import ctypes
                user32 = ctypes.windll.user32
                SM_XVIRTUALSCREEN = 76
                SM_YVIRTUALSCREEN = 77
                SM_CXVIRTUALSCREEN = 78
                SM_CYVIRTUALSCREEN = 79
                xv = user32.GetSystemMetrics(SM_XVIRTUALSCREEN)
                yv = user32.GetSystemMetrics(SM_YVIRTUALSCREEN)
                cvw = user32.GetSystemMetrics(SM_CXVIRTUALSCREEN)
                cvh = user32.GetSystemMetrics(SM_CYVIRTUALSCREEN)
                x0, y0, width, height = int(xv), int(yv), int(cvw), int(cvh)
        except Exception:
            x0, y0 = 0, 0
            width, height = img_w, img_h

        picker = tk.Toplevel(self)
        picker.overrideredirect(True)
        picker.geometry(f"{width}x{height}+{x0}+{y0}")
        try:
            picker.attributes('-topmost', True)
        except Exception:
            pass
        picker.lift()

        try:
            display_img = screen.resize((width, height))
        except Exception:
            display_img = screen

        photo = ImageTk.PhotoImage(display_img)
        
        mode = self.source_type.get()
        if mode == 'image':
            self._setup_region_picker(picker, photo, screen, x0, y0, width, height)
        else:
            self._setup_pixel_picker(picker, photo, x0, y0, width, height)

        self._screen_origin = (x0, y0)
        self._virtual_size = (width, height)
        picker.focus_force()
    
    def _setup_pixel_picker(self, picker, photo, x0, y0, width, height):
        """Setup single pixel color picker"""
        lbl = tk.Label(picker, image=photo)
        lbl.image = photo
        lbl.place(x=0, y=0, width=width, height=height)

        floating = tk.Label(picker, text='', bd=1, relief='solid', padx=12, pady=8, 
                           font=(FONT_FAMILY, 14, 'bold'))
        floating.place(x=20, y=20)

        self._picker_win = picker
        self._picker_floating = floating

        picker.bind('<Motion>', self._on_picker_move)
        picker.bind('<Button-1>', self._on_picker_click)
    
    def _setup_region_picker(self, picker, photo, screen, x0, y0, width, height):
        """Setup region selection picker for image mode"""
        canvas = tk.Canvas(picker, width=width, height=height, highlightthickness=0)
        canvas.photo = photo
        canvas.create_image(0, 0, image=photo, anchor='nw')
        canvas.pack(fill='both', expand=True)

        canvas._rect_id = None
        canvas._start = None

        def on_press(e):
            canvas._start = (e.x_root, e.y_root)
            if canvas._rect_id:
                canvas.delete(canvas._rect_id)
                canvas._rect_id = None

        def on_drag(e):
            if not canvas._start:
                return
            x0_root, y0_root = canvas._start
            x1_root, y1_root = e.x_root, e.y_root
            lx0 = int((x0_root - x0) * (width / max(1, width)))
            ly0 = int((y0_root - y0) * (height / max(1, height)))
            lx1 = int((x1_root - x0) * (width / max(1, width)))
            ly1 = int((y1_root - y0) * (height / max(1, height)))
            if canvas._rect_id:
                canvas.coords(canvas._rect_id, lx0, ly0, lx1, ly1)
            else:
                canvas._rect_id = canvas.create_rectangle(lx0, ly0, lx1, ly1, 
                                                          outline=COLORS['accent'], width=2)

        def on_release(e):
            if not canvas._start:
                return
            x0_root, y0_root = canvas._start
            x1_root, y1_root = e.x_root, e.y_root
            
            img_w, img_h = screen.size
            vw, vh = width, height
            scale_x = img_w / max(1, vw)
            scale_y = img_h / max(1, vh)
            sx = int((min(x0_root, x1_root) - x0) * scale_x)
            sy = int((min(y0_root, y1_root) - y0) * scale_y)
            ex = int((max(x0_root, x1_root) - x0) * scale_x)
            ey = int((max(y0_root, y1_root) - y0) * scale_y)
            
            sx = max(0, min(img_w - 1, sx))
            sy = max(0, min(img_h - 1, sy))
            ex = max(0, min(img_w, ex))
            ey = max(0, min(img_h, ey))
            
            if ex <= sx or ey <= sy:
                canvas._start = None
                if canvas._rect_id:
                    canvas.delete(canvas._rect_id)
                    canvas._rect_id = None
                return

            region = screen.crop((sx, sy, ex, ey))

            try:
                temp_fd, temp_path = tempfile.mkstemp(suffix='.png')
                os.close(temp_fd)
                region.save(temp_path)
            except Exception as err:
                messagebox.showerror(self.lang.get('save_error_title'), 
                                   self.lang.get('msg_save_screenshot_failed').format(error=str(err)))
                canvas._start = None
                return

            try:
                picker.destroy()
            except Exception:
                pass

            self._restore_window()

            try:
                thumb = region.copy()
                thumb.thumbnail((48, 48))
                photo_thumb = ctk.CTkImage(light_image=thumb, dark_image=thumb, size=(48, 48))
                self.img_thumbnail_label.configure(image=photo_thumb, text="")
                self.img_thumbnail = photo_thumb
                self.lbl_image.configure(text=self.lang.get('screenshot_label'))
                self.image_path = temp_path
                self._temp_screenshot = temp_path
            except Exception:
                try:
                    os.unlink(temp_path)
                except Exception:
                    pass

            try:
                colors = self.generator.extract_main_colors(temp_path, num_colors=5)
                self.extracted_colors = colors
            except Exception:
                self.extracted_colors = []

        canvas.bind('<Button-1>', on_press)
        canvas.bind('<B1-Motion>', on_drag)
        canvas.bind('<ButtonRelease-1>', on_release)
    
    def _on_picker_move(self, event):
        """Handle mouse movement in color picker"""
        x = event.x_root
        y = event.y_root
        img = self._screen_image
        x0, y0 = getattr(self, '_screen_origin', (0, 0))
        
        img_w, img_h = img.size
        vw, vh = getattr(self, '_virtual_size', (img_w, img_h))
        vw = max(1, int(vw))
        vh = max(1, int(vh))
        scale_x = img_w / vw
        scale_y = img_h / vh

        local_x = int((x - x0) * scale_x)
        local_y = int((y - y0) * scale_y)
        
        if local_x < 0 or local_y < 0 or local_x >= img_w or local_y >= img_h:
            return
        
        try:
            rgb = img.getpixel((local_x, local_y))
        except Exception:
            return
        
        if isinstance(rgb, int):
            rgb = (rgb, rgb, rgb)

        hx = self.generator.rgb_to_hex(rgb)
        lum = (0.299*rgb[0] + 0.587*rgb[1] + 0.114*rgb[2])
        txt_fill = '#000000' if lum > 160 else '#ffffff'

        f = self._picker_floating
        f.config(text=hx, bg=hx, fg=txt_fill)

        try:
            vw = int(self._picker_win.winfo_width())
            vh = int(self._picker_win.winfo_height())
        except Exception:
            vw, vh = img_w, img_h

        midx = vw / 2
        midy = vh / 2

        pad = 8
        fw = f.winfo_reqwidth()
        fh = f.winfo_reqheight()

        rel_x = x - x0
        rel_y = y - y0

        if rel_x <= midx and rel_y <= midy:
            quadrant = 1
        elif rel_x > midx and rel_y <= midy:
            quadrant = 2
        elif rel_x <= midx and rel_y > midy:
            quadrant = 3
        else:
            quadrant = 4

        opp = {1:4, 2:3, 3:2, 4:1}[quadrant]

        if opp == 1:
            place_x = int(pad)
            place_y = int(pad)
        elif opp == 2:
            place_x = int(vw - pad - fw)
            place_y = int(pad)
        elif opp == 3:
            place_x = int(pad)
            place_y = int(vh - pad - fh)
        else:
            place_x = int(vw - pad - fw)
            place_y = int(vh - pad - fh)

        place_x = max(4, min(place_x, vw - fw - 4))
        place_y = max(4, min(place_y, vh - fh - 4))
        f.place(x=place_x, y=place_y)

    def _on_picker_click(self, event):
        """Handle click in color picker"""
        hx = self._picker_floating.cget('text')
        try:
            self._picker_win.destroy()
        except Exception:
            pass
        
        self._restore_window()

        try:
            self.hex_entry.set(hx)
            self._update_color_swatch(hx)
            self.add_to_recent_colors(hx)
            self.image_path = None
            self.extracted_colors = []
        except Exception:
            pass
    
    def _restore_window(self):
        """Restore main window after screen picker"""
        try:
            if getattr(self, '_did_withdraw', False):
                self.deiconify()
                self._did_withdraw = False
            else:
                self.attributes('-alpha', self._prev_alpha)
        except Exception:
            pass

    # ============== Palette Generation ==============
    def generate(self):
        """Generate palette with comprehensive validation"""
        source_type = self.source_type.get()
        try:
            if source_type == 'ai':
                self._generate_ai_palette()
                return
            elif source_type == 'hex':
                hex_code = self.hex_entry.get().strip()
                
                if not self.validate_hex_color(hex_code):
                    raise ValueError(self.lang.get('msg_invalid_hex_prompt'))
                
                palette = self.generator.generate_palette(hex_code, source_type='hex')
                self.current_palettes = [palette]
                self.log_action(f"Generated palette from HEX: {hex_code}")
            else:
                if not self.image_path:
                    raise ValueError(self.lang.get('msg_select_image_first'))
                
                if not os.path.exists(self.image_path):
                    self.image_path = None
                    self.lbl_image.configure(text=self.lang.get('no_image_label'))
                    raise ValueError(self.lang.get('msg_image_file_not_found'))
                
                approx = self.generator.approximate_color_count(self.image_path, sample_size=1000)
                k = min(5, max(1, approx))
                main_colors = self.generator.extract_main_colors(self.image_path, num_colors=k)
                
                if not main_colors:
                    raise ValueError(self.lang.get('msg_extract_colors_failed'))
                
                self.extracted_colors = main_colors
                palettes = [self.generator.generate_palette(c, source_type='rgb') for c in main_colors]
                self.current_palettes = palettes
                self.log_action(f"Generated palette from image: {os.path.basename(self.image_path)}")
                
        except ValueError as e:
            messagebox.showerror(self.lang.get('input_error_title'), str(e))
            self.log_action(f"Generate validation error: {str(e)}")
            return
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('msg_palette_generation_failed').format(error=str(e)))
            self.log_action(f"Generate error: {str(e)}")
            return

        self.clear_palette_display()
        
        if source_type == 'ai':
            self.display_ai_palettes(self.ai_palettes)
        elif source_type == 'hex':
            self.display_single_palette(palette)
        else:
            self.display_multiple_palettes(self.current_palettes)
    
    def _generate_ai_palette(self):
        """Generate AI color palette"""
        from ai_color_recommender import AISettings, AIColorRecommender
        
        settings = AISettings.load_settings(self.file_handler)
        api_key = settings.get('api_key', '')
        
        if not api_key:
            messagebox.showwarning(self.lang.get('warning'), self.lang.get('msg_ai_api_key_required'))
            return
        
        if not self.ai_recommender:
            try:
                self.ai_recommender = AIColorRecommender(api_key, lang=self.lang)
            except Exception as e:
                messagebox.showerror(self.lang.get('error'), self.lang.get('msg_ai_init_failed').format(error=str(e)))
                return
        
        num_colors = settings.get('num_colors', 5)
        keywords = settings.get('keywords', '')
        
        # Show loading dialog
        loading_dialog = ctk.CTkToplevel(self)
        set_window_icon(loading_dialog)
        loading_dialog.title(self.lang.get('ai_generating_title'))
        loading_dialog.geometry("300x100")
        loading_dialog.transient(self)
        loading_dialog.grab_set()
        
        ctk.CTkLabel(
            loading_dialog, 
            text=self.lang.get('ai_generating'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12)
        ).pack(pady=20)
        
        progress = ctk.CTkProgressBar(loading_dialog, mode='indeterminate', width=250)
        progress.pack(pady=10)
        progress.start()
        
        def generate_ai_palettes():
            try:
                new_palettes = self.ai_recommender.generate_palettes(
                    num_palettes=5,
                    keywords=keywords,
                    num_colors=num_colors
                )
                self.after(0, lambda: self._finish_ai_generation(new_palettes, loading_dialog))
            except Exception as e:
                error_msg = str(e)
                self.after(0, lambda: self._handle_ai_error(error_msg, loading_dialog))
        
        import threading
        thread = threading.Thread(target=generate_ai_palettes, daemon=True)
        thread.start()
    
    def _finish_ai_generation(self, new_palettes, loading_dialog):
        """Handle successful AI palette generation"""
        try:
            loading_dialog.destroy()
            
            self.ai_palettes.extend(new_palettes)
            self.current_palettes = self.ai_palettes
            self.log_action(f"Generated AI palettes: {len(new_palettes)} new palettes")
            
            self.clear_palette_display()
            self.display_ai_palettes(self.ai_palettes)
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), str(e))
    
    def _handle_ai_error(self, error_msg, loading_dialog):
        """Handle AI generation error"""
        try:
            loading_dialog.destroy()
        except:
            pass
        messagebox.showerror(self.lang.get('ai_error_title'), self.lang.get('ai_generation_failed').format(error=error_msg))
        self.log_action(f"AI generation error: {error_msg}")

    def validate_hex_color(self, hex_code):
        """Validate HEX color format"""
        if not isinstance(hex_code, str):
            return False
        hex_code = hex_code.strip()
        if not hex_code.startswith('#'):
            return False
        hex_code = hex_code[1:]
        if len(hex_code) not in (3, 6):
            return False
        try:
            int(hex_code, 16)
            return True
        except ValueError:
            return False

    def generate_random(self):
        """Generate random color palette"""
        self.source_type.set('hex')
        self.on_source_change()

        rgb = self.generator.generate_random_color()
        hex_code = self.generator.rgb_to_hex(rgb)
        
        try:
            self.hex_entry.set(hex_code)
            self._update_color_swatch(hex_code)
        except Exception:
            pass
        
        self.generate()

    def clear_palette_display(self):
        """Clear palette display"""
        try:
            for child in self.palette_inner.winfo_children():
                try:
                    child.destroy()
                except Exception:
                    pass
        except Exception as e:
            self.log_action(f"Clear palette display error: {str(e)}")

    # ============== Palette Display ==============
    def draw_color_box(self, parent, hex_color, label_text, clickable=True):
        """Draw a modern color box with info, hover effect, and tooltip"""
        frm = ctk.CTkFrame(
            parent,
            fg_color=COLORS['bg_secondary'],
            corner_radius=8,
            height=60
        )
        frm.pack(fill='x', pady=3, padx=5)
        frm.pack_propagate(False)
        
        # Color swatch
        swatch = ctk.CTkFrame(
            frm,
            width=60,
            height=50,
            corner_radius=6,
            fg_color=hex_color
        )
        swatch.pack(side='left', padx=8, pady=5)
        swatch.pack_propagate(False)
        
        # Info section
        info_frame = ctk.CTkFrame(frm, fg_color="transparent")
        info_frame.pack(side='left', fill='both', expand=True, padx=10, pady=8)
        
        # Hex code
        hex_label = ctk.CTkLabel(
            info_frame,
            text=hex_color.upper(),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
            text_color=COLORS['text_primary']
        )
        hex_label.pack(anchor='w')
        
        # RGB info
        rgb_label = ctk.CTkLabel(
            info_frame,
            text=label_text,
            font=ctk.CTkFont(family=FONT_FAMILY, size=10),
            text_color=COLORS['text_secondary']
        )
        rgb_label.pack(anchor='w')
        
        if clickable:
            # Tooltip window reference
            tooltip_window = [None]
            show_after_id = [None]
            tooltip_text = self.lang.get('color_box_tooltip') if hasattr(self, 'lang') else "Left-click: Add to palette | Right-click: Set as base color"
            
            def destroy_tooltip():
                if tooltip_window[0] is not None:
                    try:
                        if hasattr(self, 'active_tooltips') and tooltip_window[0] in self.active_tooltips:
                            self.active_tooltips.remove(tooltip_window[0])
                        tooltip_window[0].destroy()
                    except Exception:
                        pass
                    tooltip_window[0] = None
            
            def show_tooltip(x_root, y_root):
                destroy_tooltip()
                tip = ctk.CTkToplevel(self)
                tip.wm_overrideredirect(True)
                try:
                    tip.wm_attributes('-topmost', True)
                except Exception:
                    pass
                tip.wm_geometry(f"+{x_root + 10}+{y_root + 10}")
                tip.configure(fg_color=COLORS['bg_card'])
                
                label = ctk.CTkLabel(
                    tip,
                    text=tooltip_text,
                    font=ctk.CTkFont(family=FONT_FAMILY, size=10),
                    text_color=COLORS['text_primary']
                )
                label.pack(padx=8, pady=4)
                tooltip_window[0] = tip
                if hasattr(self, 'active_tooltips'):
                    self.active_tooltips.append(tip)
            
            # Combined hover effect and tooltip
            def on_enter(e=None):
                frm.configure(fg_color=COLORS['bg_hover'])
                if e:
                    if show_after_id[0] is not None:
                        try:
                            frm.after_cancel(show_after_id[0])
                        except Exception:
                            pass
                        show_after_id[0] = None
                    
                    show_after_id[0] = frm.after(120, lambda: show_tooltip(e.x_root, e.y_root))
            
            def on_leave(e=None):
                frm.configure(fg_color=COLORS['bg_secondary'])
                if show_after_id[0] is not None:
                    try:
                        frm.after_cancel(show_after_id[0])
                    except Exception:
                        pass
                    show_after_id[0] = None
                destroy_tooltip()
            
            def on_motion(e):
                if tooltip_window[0] is not None:
                    try:
                        tooltip_window[0].wm_geometry(f"+{e.x_root + 10}+{e.y_root + 10}")
                    except Exception:
                        pass
            
            # Left click - add to saved palette
            def on_left_click(e=None):
                self.on_palette_color_click(hex_color)
            
            # Right click - set as base color
            def on_right_click(e=None):
                self.set_base_color(hex_color)
            
            for widget in [frm, swatch, info_frame, hex_label, rgb_label]:
                widget.bind('<Button-1>', on_left_click)
                widget.bind('<Button-3>', on_right_click)
                widget.bind('<Enter>', on_enter)
                widget.bind('<Leave>', on_leave)
                widget.bind('<Motion>', on_motion)
                try:
                    widget.configure(cursor='hand2')
                except Exception:
                    pass
    
    def set_base_color(self, hex_color):
        """Set the clicked color as the base color and regenerate palette"""
        try:
            # Set source type to HEX
            self.source_type.set('hex')
            self.on_source_change()
            
            # Set the color in hex_entry
            self.hex_entry.set(hex_color)
            self._update_color_swatch(hex_color)
            
            # Regenerate palette
            self.generate()
            self.log_action(f"Set base color to {hex_color}")
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), f"Failed to set base color: {str(e)}")

    def display_single_palette(self, palette):
        """Display a single palette (for HEX mode)"""
        base = palette['base']
        if isinstance(base, list):
            base = tuple(base)
        base_hex = self.generator.rgb_to_hex(base)
        
        # Base color header
        header = ctk.CTkLabel(
            self.palette_inner,
            text=self.lang.get('base_color_label'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=13, weight="bold"),
            text_color=COLORS['text_primary']
        )
        header.pack(anchor='w', padx=5, pady=(10, 5))
        
        self.draw_color_box(self.palette_inner, base_hex, f"RGB{base}")

        scheme_labels = {
            'complementary': self.lang.get('complementary_label'),
            'analogous': self.lang.get('analogous_label'),
            'triadic': self.lang.get('triadic_label'),
            'monochromatic': self.lang.get('monochromatic'),
            'split_complementary': self.lang.get('split_complementary'),
            'square': self.lang.get('square'),
            'tetradic': self.lang.get('tetradic'),
            'double_complementary': self.lang.get('double_complementary')
        }

        for scheme in self.selected_schemes:
            if scheme.startswith('custom_'):
                self._display_custom_harmony(scheme, base_hex)
            elif scheme in palette:
                colors = palette[scheme]
                label = scheme_labels.get(scheme, scheme)
                
                scheme_header = ctk.CTkLabel(
                    self.palette_inner,
                    text=label,
                    font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
                    text_color=COLORS['text_primary']
                )
                scheme_header.pack(anchor='w', padx=5, pady=(15, 5))
                
                if isinstance(colors, (tuple, list)) and len(colors) == 3 and all(isinstance(c, int) for c in colors):
                    if isinstance(colors, list):
                        colors = tuple(colors)
                    hx = self.generator.rgb_to_hex(colors)
                    self.draw_color_box(self.palette_inner, hx, f"RGB{colors}")
                else:
                    for idx, col in enumerate(colors, 1):
                        if isinstance(col, list):
                            col = tuple(col)
                        hx = self.generator.rgb_to_hex(col)
                        self.draw_color_box(self.palette_inner, hx, f"{idx}. RGB{col}")
    
    def _display_custom_harmony(self, scheme, base_hex):
        """Display custom harmony colors"""
        try:
            from custom_harmony import CustomHarmonyManager
            manager = CustomHarmonyManager(self.file_handler)
            idx = int(scheme.split('_')[1])
            
            if idx < len(manager.harmonies):
                harmony = manager.harmonies[idx]
                colors = manager.apply_harmony(base_hex, idx)
                label = harmony.get('name', self.lang.get('custom_harmony_default_name'))
                
                scheme_header = ctk.CTkLabel(
                    self.palette_inner,
                    text=label,
                    font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
                    text_color=COLORS['text_primary']
                )
                scheme_header.pack(anchor='w', padx=5, pady=(15, 5))
                
                for color_idx, color_hex in enumerate(colors, 1):
                    rgb = self.generator.hex_to_rgb(color_hex)
                    self.draw_color_box(self.palette_inner, color_hex, f"{color_idx}. RGB{rgb}")
        except Exception:
            pass

    def display_multiple_palettes(self, palettes):
        """Display multiple palettes (for image mode)"""
        scheme_labels = {
            'complementary': self.lang.get('complementary'),
            'analogous': self.lang.get('analogous'),
            'triadic': self.lang.get('triadic'),
            'monochromatic': self.lang.get('monochromatic'),
            'split_complementary': self.lang.get('split_complementary'),
            'square': self.lang.get('square'),
            'tetradic': self.lang.get('tetradic'),
            'double_complementary': self.lang.get('double_complementary')
        }
        
        for i, p in enumerate(palettes, start=1):
            palette_header = ctk.CTkLabel(
                self.palette_inner,
                text=f" {self.lang.get('representative_color')} {i}",
                image=self._get_icon('palette'),
                compound='left',
                font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
                text_color=COLORS['accent_light']
            )
            palette_header.pack(anchor='w', padx=5, pady=(15, 5))
            
            base = p['base']
            if isinstance(base, list):
                base = tuple(base)
            base_hex = self.generator.rgb_to_hex(base)
            self.draw_color_box(self.palette_inner, base_hex, f"{self.lang.get('base_color')} RGB{base}")

            for scheme in self.selected_schemes:
                if scheme.startswith('custom_'):
                    self._display_custom_harmony(scheme, base_hex)
                elif scheme in p:
                    colors = p[scheme]
                    label = scheme_labels.get(scheme, scheme)
                    
                    scheme_label = ctk.CTkLabel(
                        self.palette_inner,
                        text=f"  {label}",
                        font=ctk.CTkFont(family=FONT_FAMILY, size=11, weight="bold"),
                        text_color=COLORS['text_secondary']
                    )
                    scheme_label.pack(anchor='w', padx=5)
                    
                    if isinstance(colors, (tuple, list)) and len(colors) == 3 and all(isinstance(c, int) for c in colors):
                        if isinstance(colors, list):
                            colors = tuple(colors)
                        hx = self.generator.rgb_to_hex(colors)
                        self.draw_color_box(self.palette_inner, hx, f"RGB{colors}")
                    else:
                        for idx, col in enumerate(colors, 1):
                            if isinstance(col, list):
                                col = tuple(col)
                            hx = self.generator.rgb_to_hex(col)
                            self.draw_color_box(self.palette_inner, hx, f"{idx}. RGB{col}")
            
            # Separator between palettes
            if i < len(palettes):
                sep = ctk.CTkFrame(self.palette_inner, height=2, fg_color=COLORS['border'])
                sep.pack(fill='x', pady=15, padx=10)

    def display_ai_palettes(self, palettes):
        """Display AI-generated color palettes"""
        if not palettes:
            empty_label = ctk.CTkLabel(
                self.palette_inner,
                text=self.lang.get('ai_no_palettes'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12),
                text_color=COLORS['text_muted']
            )
            empty_label.pack(pady=20)
            return
        
        for i, palette_data in enumerate(palettes, start=1):
            if isinstance(palette_data, dict):
                palette_name = palette_data.get('name', self.lang.get('ai_palette_name').format(i=i))
                palette_colors = palette_data.get('colors', [])
            else:
                palette_name = self.lang.get('ai_palette_name').format(i=i)
                palette_colors = palette_data
            
            header = ctk.CTkLabel(
                self.palette_inner,
                text=f" {palette_name}",
                image=self._get_icon('sparkle'),
                compound='left',
                font=ctk.CTkFont(family=FONT_FAMILY, size=13, weight="bold"),
                text_color=COLORS['accent_light']
            )
            header.pack(anchor='w', padx=5, pady=(15 if i > 1 else 5, 5))
            
            for j, color_hex in enumerate(palette_colors, start=1):
                rgb = self.generator.hex_to_rgb(color_hex)
                self.draw_color_box(self.palette_inner, color_hex, f"{j}. RGB{rgb}")
            
            if i < len(palettes):
                sep = ctk.CTkFrame(self.palette_inner, height=2, fg_color=COLORS['border'])
                sep.pack(fill='x', pady=15, padx=10)

    # ============== Saved Palettes Management ==============
    def add_saved_palette(self):
        """Add a new saved palette"""
        name = self.lang.get('new_palette_numbered').format(i=self._saved_counter + 1)
        self._saved_counter += 1

        entry = {'name': name, 'colors': []}
        self.saved_palettes.append(entry)
        self.render_saved_list()
        self.mark_modified()
        self.log_action(f"Added new palette: {name}")

    def remove_saved_palette(self):
        """Remove selected palette"""
        if len(self.saved_palettes) <= 1 or self._saved_selected is None:
            return
        
        idx = self._saved_selected
        palette_name = self.saved_palettes[idx]['name'] if idx < len(self.saved_palettes) else 'Unknown'
        
        try:
            del self.saved_palettes[idx]
        except Exception:
            return
        
        if not self.saved_palettes:
            self._saved_selected = None
        else:
            self._saved_selected = max(0, idx - 1)
        
        self.render_saved_list()
        self.log_action(f"Removed palette: {palette_name}")
        self.mark_modified()

    def on_palette_color_click(self, hex_color):
        """Handle clicks on palette swatches"""
        if self._saved_selected is None:
            messagebox.showinfo(self.lang.get('selection_required'), self.lang.get('select_palette_first'))
            return
        
        try:
            entry = self.saved_palettes[self._saved_selected]
            hex_str = hex_color if isinstance(hex_color, str) else self.generator.rgb_to_hex(hex_color)
            
            entry['colors'].append(hex_str)
            self.add_to_recent_colors(hex_str)
            
            self._update_single_palette_entry(self._saved_selected)
            self.mark_modified()
            self.log_action(f"Added color {hex_str} to palette: {entry['name']}")
        except Exception as e:
            self.log_action(f"Error adding color to palette: {str(e)}")

    def render_saved_list(self):
        """Render saved palettes list with modern design"""
        for c in self.saved_list_container.winfo_children():
            try:
                c.destroy()
            except Exception:
                pass
        
        # Store widget references for incremental updates
        self._palette_widgets = {}

        for idx, entry in enumerate(self.saved_palettes):
            self._create_palette_entry_widget(idx, entry)

        self.update_menu_states()

    def _create_palette_entry_widget(self, idx, entry):
        """Create a single palette entry widget and store references"""
        is_selected = self._saved_selected == idx
        
        # Palette card
        palette_frame = ctk.CTkFrame(
            self.saved_list_container,
            corner_radius=8,
            fg_color=COLORS['accent'] if is_selected else COLORS['bg_secondary'],
            border_width=2 if is_selected else 1,
            border_color=COLORS['accent_light'] if is_selected else COLORS['border']
        )
        palette_frame.pack(fill='x', pady=4, padx=2)
        
        # Header with name
        header = ctk.CTkFrame(palette_frame, fg_color="transparent")
        header.pack(fill='x', padx=10, pady=(8, 5))
        
        name_label = ctk.CTkLabel(
            header,
            text=entry.get('name', self.lang.get('palette_numbered').format(i=idx+1)),
            font=ctk.CTkFont(family=FONT_FAMILY, size=11, weight="bold"),
            text_color=COLORS['text_primary']
        )
        name_label.pack(side='left')
        
        # Color count badge
        color_count = len(entry.get('colors', []))
        count_label = ctk.CTkLabel(
            header,
            text=self.lang.get('colors_count').format(count=color_count),
            font=ctk.CTkFont(family=FONT_FAMILY, size=9),
            text_color=COLORS['text_muted']
        )
        count_label.pack(side='right')
        
        # Color bar with Canvas for variable width ratio
        colors = entry.get('colors', [])
        canvas = None
        bar_container = None
        if colors:
            bar_container = ctk.CTkFrame(palette_frame, height=30, fg_color="transparent")
            bar_container.pack(fill='x', padx=10, pady=(0, 8))
            bar_container.pack_propagate(False)
            
            display_colors = colors  # Show ALL colors
            
            # Use Canvas for precise width calculation
            canvas = tk.Canvas(
                bar_container,
                height=30,
                bg=COLORS['bg_secondary'],
                highlightthickness=0
            )
            canvas.pack(fill='both', expand=True)
            
            # Store display_colors for redraw
            canvas._display_colors = display_colors
            
            # Wait for canvas to render and get actual width
            def draw_palette_bar(c=canvas):
                try:
                    c.delete('all')
                    c.update_idletasks()
                    canvas_width = c.winfo_width()
                    if canvas_width <= 1:
                        canvas_width = 400
                    
                    dc = c._display_colors
                    box_width = float(canvas_width) / float(len(dc))
                    for i, color in enumerate(dc):
                        x1 = int(i * box_width)
                        x2 = int((i + 1) * box_width)
                        c.create_rectangle(x1, 0, x2, 30, fill=color, outline='')
                except Exception:
                    pass
            
            canvas.after(50, draw_palette_bar)
        else:
            # Empty palette indicator
            empty_label = ctk.CTkLabel(
                palette_frame,
                text=self.lang.get('empty_palette_msg'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=9),
                text_color=COLORS['text_muted']
            )
            empty_label.pack(pady=(0, 8))
        
        # Store widget references
        self._palette_widgets[idx] = {
            'frame': palette_frame,
            'header': header,
            'name_label': name_label,
            'count_label': count_label,
            'canvas': canvas,
            'bar_container': bar_container,
        }
        
        # Click binding - optimize selection (no full re-render)
        def make_select(i):
            def select_handler(e=None):
                if self._saved_selected != i:
                    prev = self._saved_selected
                    self._saved_selected = i
                    self._update_selection_style(prev, i)
                    self.update_menu_states()
            return select_handler
        
        for widget in [palette_frame, header, name_label]:
            widget.bind('<Button-1>', make_select(idx))
            try:
                widget.configure(cursor='hand2')
            except Exception:
                pass
        
        # Right-click context menu
        def make_context_menu(i):
            return lambda e: self.show_palette_context_menu(i, e)
        
        for widget in [palette_frame, header, name_label]:
            widget.bind('<Button-3>', make_context_menu(idx))
        
        # Double-click to edit
        def make_edit(i):
            return lambda e: self.open_palette_editor(i)
        
        for widget in [palette_frame, header, name_label]:
            widget.bind('<Double-Button-1>', make_edit(idx))

    def _update_selection_style(self, old_idx, new_idx):
        """Update visual selection state without re-rendering"""
        if not hasattr(self, '_palette_widgets'):
            return
        # Deselect old
        if old_idx is not None and old_idx in self._palette_widgets:
            w = self._palette_widgets[old_idx]
            try:
                w['frame'].configure(
                    fg_color=COLORS['bg_secondary'],
                    border_width=1,
                    border_color=COLORS['border']
                )
            except Exception:
                pass
        # Select new
        if new_idx is not None and new_idx in self._palette_widgets:
            w = self._palette_widgets[new_idx]
            try:
                w['frame'].configure(
                    fg_color=COLORS['accent'],
                    border_width=2,
                    border_color=COLORS['accent_light']
                )
            except Exception:
                pass

    def _update_single_palette_entry(self, idx):
        """Update a single palette entry's color bar and count without re-rendering everything"""
        if not hasattr(self, '_palette_widgets') or idx not in self._palette_widgets:
            self.render_saved_list()
            return
        
        entry = self.saved_palettes[idx]
        colors = entry.get('colors', [])
        widgets = self._palette_widgets[idx]
        
        # Update count label
        try:
            widgets['count_label'].configure(
                text=self.lang.get('colors_count').format(count=len(colors))
            )
        except Exception:
            pass
        
        # Update color bar
        canvas = widgets.get('canvas')
        bar_container = widgets.get('bar_container')
        palette_frame = widgets.get('frame')
        
        if colors and canvas is not None:
            # Just redraw the canvas with updated colors
            canvas._display_colors = colors
            try:
                canvas.delete('all')
                canvas.update_idletasks()
                canvas_width = canvas.winfo_width()
                if canvas_width <= 1:
                    canvas_width = 400
                box_width = float(canvas_width) / float(len(colors))
                for i, color in enumerate(colors):
                    x1 = int(i * box_width)
                    x2 = int((i + 1) * box_width)
                    canvas.create_rectangle(x1, 0, x2, 30, fill=color, outline='')
            except Exception:
                pass
        elif colors and canvas is None:
            # Had no colors before, now has colors - create canvas in-place
            try:
                # Remove the empty palette label if it exists
                for child in palette_frame.winfo_children():
                    if isinstance(child, ctk.CTkLabel) and child not in [widgets.get('name_label'), widgets.get('count_label')]:
                        # Check if this is the empty palette message label (not in header)
                        if child.master == palette_frame:
                            child.destroy()

                bar_container = ctk.CTkFrame(palette_frame, height=30, fg_color="transparent")
                bar_container.pack(fill='x', padx=10, pady=(0, 8))
                bar_container.pack_propagate(False)

                canvas = tk.Canvas(
                    bar_container,
                    height=30,
                    bg=COLORS['bg_secondary'],
                    highlightthickness=0
                )
                canvas.pack(fill='both', expand=True)
                canvas._display_colors = colors

                # Update widget references
                widgets['canvas'] = canvas
                widgets['bar_container'] = bar_container

                def draw_palette_bar(c=canvas):
                    try:
                        c.delete('all')
                        c.update_idletasks()
                        canvas_width = c.winfo_width()
                        if canvas_width <= 1:
                            canvas_width = 400
                        dc = c._display_colors
                        box_width = float(canvas_width) / float(len(dc))
                        for i, color in enumerate(dc):
                            x1 = int(i * box_width)
                            x2 = int((i + 1) * box_width)
                            c.create_rectangle(x1, 0, x2, 30, fill=color, outline='')
                    except Exception:
                        pass

                canvas.after(50, draw_palette_bar)

                # Bind click events to new widgets
                for w in [bar_container, canvas]:
                    w.bind('<Button-1>', lambda e, i=idx: self._select_saved_entry(i))
                    w.bind('<Button-3>', lambda e, i=idx: self.show_palette_context_menu(i, e))
                    w.bind('<Double-Button-1>', lambda e, i=idx: self.on_palette_color_click(i, e))
            except Exception:
                pass

    def _select_saved_entry(self, idx):
        """Select a saved palette entry"""
        prev = self._saved_selected
        self._saved_selected = idx
        self._update_selection_style(prev, idx)
        self.update_menu_states()

    def show_palette_context_menu(self, idx, event):
        """Show context menu for palette operations"""
        prev = self._saved_selected
        self._saved_selected = idx
        self._update_selection_style(prev, idx)
        self.update_menu_states()
        
        entry = self.saved_palettes[idx]
        current_mode = entry.get('view_mode', 'rgb')
        view_label = self.lang.get('view_rgb') if current_mode == 'value' else self.lang.get('view_value')
        
        menu = tk.Menu(self, tearoff=0, bg=COLORS['bg_card'], fg=COLORS['text_primary'])
        menu.add_command(label=self.lang.get('context_rename'), command=lambda: self.rename_palette(idx))
        menu.add_command(label=self.lang.get('context_edit_palette'), command=lambda: self.open_palette_editor(idx))
        menu.add_command(label=self.lang.get('context_save_palette'), command=lambda: self.save_palette_file(idx))
        menu.add_separator()
        menu.add_command(label=self.lang.get('context_export_txt'), command=lambda: self.export_palette_txt(idx))
        menu.add_command(label=self.lang.get('context_export_png'), command=lambda: self.export_palette_png(idx))
        menu.add_separator()
        menu.add_command(label=view_label, command=lambda: self.toggle_palette_view(idx))
        
        try:
            menu.post(event.x_root, event.y_root)
        except Exception:
            pass

    def copy_palette(self):
        """Copy currently selected palette"""
        if self._saved_selected is None:
            messagebox.showinfo(self.lang.get('selection_required'), self.lang.get('select_palette_first'))
            return
        try:
            entry = self.saved_palettes[self._saved_selected]
            new_entry = {
                'name': f"{entry['name']}{self.lang.get('copy_suffix')}",
                'colors': entry['colors'].copy()
            }
            self.saved_palettes.append(new_entry)
            self._saved_selected = len(self.saved_palettes) - 1
            self.render_saved_list()
            self.mark_modified()
            self.log_action(f"Copied palette: {entry['name']}")
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), str(e))

    def load_palette(self):
        """Load palette from .mps file"""
        try:
            metadata = self.file_handler.clean_palette_metadata()
            
            if not metadata:
                filename = filedialog.askopenfilename(
                    title=self.lang.get('dialog_open_mps'),
                    filetypes=[(self.lang.get('my_palette_file'), '*.mps'), (self.lang.get('all_files'), '*.*')]
                )
                if filename:
                    self._load_palette_from_file(filename)
            else:
                self._show_palette_selection_dialog(metadata)
                
        except Exception as e:
            messagebox.showerror(self.lang.get('load_error_title'), self.lang.get('msg_load_failed').format(error=str(e)))
            self.log_action(f"Load palette failed: {str(e)}")
    
    def _load_palette_from_file(self, filename):
        """Load palette from a specific file"""
        try:
            import json
            import base64
            with open(filename, 'r', encoding='utf-8') as f:
                encoded = f.read()
            data = json.loads(base64.b64decode(encoded.encode('utf-8')).decode('utf-8'))
            new_entry = {'name': data['name'], 'colors': data['colors']}
            self.saved_palettes.append(new_entry)
            self._saved_selected = len(self.saved_palettes) - 1
            self.render_saved_list()
            self.mark_modified()
            
            self.file_handler.add_palette_metadata(data['name'], data['colors'], filename)
            self.log_action(f"Loaded palette from MPS: {data['name']}")
        except Exception as e:
            raise e

    # ============== Menu Functions ==============
    def show_file_menu(self):
        """Show file operations menu"""
        menu = tk.Menu(self, tearoff=0, bg=COLORS['bg_card'], fg=COLORS['text_primary'])
        menu.add_command(label=self.lang.get('file_new'), command=self.new_pgf)
        menu.add_command(label=self.lang.get('file_save'), command=self.save_pgf)
        menu.add_command(label=self.lang.get('file_save_as'), command=self.save_pgf_as)
        menu.add_command(label=self.lang.get('file_open'), command=self.load_pgf)
        menu.add_separator()
        
        # Recent files submenu
        recent_menu = tk.Menu(menu, tearoff=0, bg=COLORS['bg_card'], fg=COLORS['text_primary'])
        recent_files = self.load_recent_files()
        if recent_files:
            for filepath in recent_files:
                filename = os.path.basename(filepath)
                recent_menu.add_command(label=filename, command=lambda p=filepath: self.load_recent_file(p))
        else:
            recent_menu.add_command(label=self.lang.get('no_recent_files'), state='disabled')
        
        menu.add_cascade(label=self.lang.get('open_recent'), menu=recent_menu)
        menu.add_separator()
        menu.add_command(label=self.lang.get('file_exit'), command=self.on_closing)
        
        try:
            x = self.file_menu_btn.winfo_rootx()
            y = self.file_menu_btn.winfo_rooty() + self.file_menu_btn.winfo_height()
            menu.post(x, y)
        except Exception:
            pass

    def show_tools_menu(self):
        """Show tools menu"""
        menu = tk.Menu(self, tearoff=0, bg=COLORS['bg_card'], fg=COLORS['text_primary'])
        menu.add_command(label=self.lang.get('apply_palette_to_image'), command=self.apply_palette_to_image)
        menu.add_separator()
        menu.add_command(label=self.lang.get('custom_color_harmonies'), command=self.open_custom_harmony)
        menu.add_separator()
        menu.add_command(label=self.lang.get('preset_palettes'), command=self.open_preset_palettes)
        menu.add_separator()
        menu.add_command(label=self.lang.get('settings_api'), command=self.open_ai_settings)
        
        try:
            x = self.tools_btn.winfo_rootx()
            y = self.tools_btn.winfo_rooty() + self.tools_btn.winfo_height()
            menu.post(x, y)
        except Exception:
            pass

    # ============== Harmony Selector ==============
    def open_harmony_selector(self):
        """Open harmony scheme selector dialog"""
        dialog = ctk.CTkToplevel(self)
        set_window_icon(dialog)
        dialog.title(self.lang.get('harmonies_title'))
        dialog.geometry("450x550")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(fg_color=COLORS['bg_dark'])

        # Header
        ctk.CTkLabel(
            dialog,
            text=self.lang.get('select_harmonies'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(pady=15, padx=15, anchor='w')

        # Scrollable frame for checkboxes
        scroll_frame = ctk.CTkScrollableFrame(dialog, fg_color=COLORS['bg_secondary'])
        scroll_frame.pack(fill='both', expand=True, padx=15, pady=5)

        schemes = [
            ('complementary', self.lang.get('complementary_label')),
            ('analogous', self.lang.get('analogous_label')),
            ('triadic', self.lang.get('triadic_label')),
            ('monochromatic', self.lang.get('monochromatic')),
            ('split_complementary', self.lang.get('split_complementary')),
            ('square', self.lang.get('square')),
            ('tetradic', self.lang.get('tetradic')),
            ('double_complementary', self.lang.get('double_complementary')),
        ]

        scheme_vars = {}
        for scheme_key, scheme_label in schemes:
            var = ctk.BooleanVar(value=(scheme_key in self.selected_schemes))
            scheme_vars[scheme_key] = var
            cb = ctk.CTkCheckBox(
                scroll_frame,
                text=scheme_label,
                variable=var,
                fg_color=COLORS['accent'],
                hover_color=COLORS['accent_hover'],
                text_color=COLORS['text_primary']
            )
            cb.pack(anchor='w', pady=5, padx=10)
        
        # Custom harmonies
        try:
            from custom_harmony import CustomHarmonyManager
            manager = CustomHarmonyManager(self.file_handler)
            
            if manager.harmonies:
                sep = ctk.CTkFrame(scroll_frame, height=1, fg_color=COLORS['border'])
                sep.pack(fill='x', pady=10)
                
                ctk.CTkLabel(
                    scroll_frame,
                    text=self.lang.get('custom_harmonies'),
                    font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
                    text_color=COLORS['text_primary']
                ).pack(anchor='w', pady=5, padx=10)
                
                for i, harmony in enumerate(manager.harmonies):
                    harmony_name = harmony.get('name', self.lang.get('custom_harmony_numbered').format(i=i + 1))
                    scheme_key = f'custom_{i}'
                    var = ctk.BooleanVar(value=(scheme_key in self.selected_schemes))
                    scheme_vars[scheme_key] = var
                    cb = ctk.CTkCheckBox(
                        scroll_frame,
                        text=harmony_name,
                        variable=var,
                        fg_color=COLORS['accent'],
                        hover_color=COLORS['accent_hover'],
                        text_color=COLORS['text_primary']
                    )
                    cb.pack(anchor='w', pady=5, padx=10)
        except ImportError:
            pass

        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(pady=15, fill='x', padx=15)

        def apply_selection():
            self.selected_schemes = [key for key, var in scheme_vars.items() if var.get()]
            if not self.selected_schemes:
                messagebox.showwarning(self.lang.get('warning'), self.lang.get('msg_select_harmony_required'))
                return
            dialog.destroy()
            self.generate()

        ModernButton(btn_frame, text=self.lang.get('ok'), command=apply_selection, width=100).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('cancel'), command=dialog.destroy, width=100).pack(side='left', padx=5)

    # ============== Settings ==============
    def open_settings(self):
        """Open settings dialog"""
        dialog = ctk.CTkToplevel(self)
        set_window_icon(dialog)
        dialog.title(self.lang.get('dialog_settings'))
        dialog.geometry("550x650")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(fg_color=COLORS['bg_dark'])

        # Scrollable content
        scroll = ctk.CTkScrollableFrame(dialog, fg_color=COLORS['bg_secondary'])
        scroll.pack(fill='both', expand=True, padx=15, pady=15)

        # Language settings
        ctk.CTkLabel(
            scroll,
            text=self.lang.get('settings_language_section'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(anchor='w', pady=(10, 10))
        
        current_lang = self.config_manager.get('language', 'ko')
        lang_var = ctk.StringVar(value='\ud55c\uad6d\uc5b4' if current_lang == 'ko' else 'English')
        
        lang_frame = ctk.CTkFrame(scroll, fg_color="transparent")
        lang_frame.pack(fill='x', padx=10, pady=5)
        
        ctk.CTkLabel(lang_frame, text=self.lang.get('language_label'), text_color=COLORS['text_secondary']).pack(side='left')
        lang_combo = ctk.CTkComboBox(
            lang_frame,
            values=['\ud55c\uad6d\uc5b4', 'English'],
            variable=lang_var,
            fg_color=COLORS['bg_card'],
            button_color=COLORS['accent'],
            button_hover_color=COLORS['accent_hover']
        )
        lang_combo.pack(side='left', padx=10)

        # Auto-save settings
        sep1 = ctk.CTkFrame(scroll, height=1, fg_color=COLORS['border'])
        sep1.pack(fill='x', pady=15)
        
        ctk.CTkLabel(
            scroll,
            text=self.lang.get('settings_autosave_section'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(anchor='w', pady=(0, 10))
        
        auto_save_var = ctk.BooleanVar(value=self.config_manager.get('auto_save_enabled', True))
        ctk.CTkCheckBox(
            scroll,
            text=self.lang.get('settings_autosave_enable'),
            variable=auto_save_var,
            fg_color=COLORS['accent'],
            hover_color=COLORS['accent_hover'],
            text_color=COLORS['text_primary']
        ).pack(anchor='w', padx=10)
        
        interval_frame = ctk.CTkFrame(scroll, fg_color="transparent")
        interval_frame.pack(fill='x', padx=10, pady=10)
        
        ctk.CTkLabel(interval_frame, text=self.lang.get('settings_autosave_interval'), text_color=COLORS['text_secondary']).pack(side='left')
        interval_var = ctk.IntVar(value=self.config_manager.get('auto_save_interval', 300))
        interval_entry = ctk.CTkEntry(interval_frame, textvariable=interval_var, width=80, fg_color=COLORS['bg_card'])
        interval_entry.pack(side='left', padx=10)
        ctk.CTkLabel(interval_frame, text="sec", text_color=COLORS['text_muted']).pack(side='left')

        # UI settings
        sep2 = ctk.CTkFrame(scroll, height=1, fg_color=COLORS['border'])
        sep2.pack(fill='x', pady=15)
        
        ctk.CTkLabel(
            scroll,
            text=self.lang.get('settings_ui_section'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(anchor='w', pady=(0, 10))
        
        window_frame = ctk.CTkFrame(scroll, fg_color="transparent")
        window_frame.pack(fill='x', padx=10, pady=5)
        
        ctk.CTkLabel(window_frame, text=self.lang.get('settings_window_size'), text_color=COLORS['text_secondary']).pack(side='left')
        width_var = ctk.IntVar(value=self.config_manager.get('window_width', 1100))
        height_var = ctk.IntVar(value=self.config_manager.get('window_height', 700))
        ctk.CTkEntry(window_frame, textvariable=width_var, width=70, fg_color=COLORS['bg_card']).pack(side='left', padx=5)
        ctk.CTkLabel(window_frame, text="x", text_color=COLORS['text_muted']).pack(side='left')
        ctk.CTkEntry(window_frame, textvariable=height_var, width=70, fg_color=COLORS['bg_card']).pack(side='left', padx=5)

        recent_colors_frame = ctk.CTkFrame(scroll, fg_color="transparent")
        recent_colors_frame.pack(fill='x', padx=10, pady=10)
        
        ctk.CTkLabel(recent_colors_frame, text=self.lang.get('settings_recent_colors'), text_color=COLORS['text_secondary']).pack(side='left')
        max_recent_colors_var = ctk.IntVar(value=self.config_manager.get('max_recent_colors', 50))
        ctk.CTkEntry(recent_colors_frame, textvariable=max_recent_colors_var, width=70, fg_color=COLORS['bg_card']).pack(side='left', padx=10)

        # Button frame
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(pady=15, padx=15, fill='x')

        def save_settings():
            new_lang = 'ko' if lang_var.get() == '\ud55c\uad6d\uc5b4' else 'en'
            self.config_manager.set('language', new_lang)
            self.config_manager.set('auto_save_enabled', auto_save_var.get())
            self.config_manager.set('auto_save_interval', interval_var.get())
            self.config_manager.set('window_width', width_var.get())
            self.config_manager.set('window_height', height_var.get())
            self.config_manager.set('max_recent_colors', max(1, min(100, max_recent_colors_var.get())))
            
            if self.config_manager.save_config():
                messagebox.showinfo(self.lang.get('settings_saved_title'), self.lang.get('settings_saved'))
                self.log_action("Settings saved")
                
                self.auto_save_enabled = auto_save_var.get()
                self.auto_save_interval = interval_var.get() * 1000
                if self.auto_save_enabled:
                    self.stop_auto_save()
                    self.start_auto_save()
                else:
                    self.stop_auto_save()

                self.max_recent_colors = max(1, min(100, max_recent_colors_var.get()))
                if len(self.recent_colors) > self.max_recent_colors:
                    self.recent_colors = self.recent_colors[:self.max_recent_colors]
                    self.config_manager.set('recent_colors', self.recent_colors)
                    self.config_manager.save_config()
                self.update_recent_colors_display()
                
                dialog.destroy()
            else:
                messagebox.showerror(self.lang.get('settings_save_failed_title'), self.lang.get('settings_save_failed'))

        ModernButton(btn_frame, text=self.lang.get('button_save'), command=save_settings, width=100).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('button_cancel'), command=dialog.destroy, width=100).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('reset_to_defaults'), command=self.reset_settings, width=150).pack(side='right', padx=5)

    def reset_settings(self):
        """Reset settings to default"""
        response = messagebox.askyesno(self.lang.get('reset_settings_title'), self.lang.get('msg_reset_settings_confirm'))
        if response:
            self.config_manager.reset_to_defaults()
            messagebox.showinfo(self.lang.get('reset_done_title'), self.lang.get('msg_settings_reset_done'))
            self.log_action("Settings reset to defaults")

    # ============== File Operations ==============
    def new_pgf(self):
        """Create new workspace"""
        if self.is_modified:
            response = messagebox.askyesnocancel(self.lang.get('save_prompt_title'), self.lang.get('msg_save_changes_prompt'))
            if response is None:
                return
            elif response:
                saved = self.save_pgf()
                if not saved:
                    return
        
        self.saved_palettes = [{'name': self.lang.get('new_palette_numbered').format(i=1), 'colors': []}]
        self.selected_schemes = ['complementary', 'analogous', 'triadic', 'monochromatic']
        self.source_type.set('hex')
        self.hex_entry.set('#3498db')
        self.current_palettes = []
        self._saved_counter = 1
        self._saved_selected = 0
        self.current_file = None
        
        self._update_color_swatch('#3498db')
        self.on_source_change()
        self.render_saved_list()
        self.clear_palette_display()
        
        self.is_modified = False
        self.update_title()
        self.log_action("Created new workspace")

    def save_pgf(self):
        """Save workspace"""
        if self.current_file:
            return self._save_to_file(self.current_file)
        else:
            try:
                path = filedialog.asksaveasfilename(
                    title=self.lang.get('dialog_save_pgf'),
                    initialdir=os.getcwd(),
                    defaultextension='.pgf',
                    filetypes=[('PGF file', '*.pgf')]
                )
                if not path:
                    return False
                
                result = self._save_to_file(path)
                if result:
                    self.log_action(f"Saved new workspace: {path}")
                return result
            except Exception as e:
                messagebox.showerror(self.lang.get('save_error_title'), self.lang.get('msg_save_failed').format(error=str(e)))
                return False

    def save_pgf_as(self):
        """Save As"""
        try:
            if not self.current_file:
                return False
            
            path = filedialog.asksaveasfilename(
                title=self.lang.get('dialog_save_as'),
                initialdir=os.getcwd(),
                defaultextension='.pgf',
                filetypes=[('PGF file', '*.pgf')]
            )
            if not path:
                return False
            
            result = self._save_to_file(path)
            if result:
                self.log_action(f"Saved workspace as: {path}")
            return result
        except Exception as e:
            messagebox.showerror(self.lang.get('save_error_title'), self.lang.get('msg_save_failed').format(error=str(e)))
            return False

    def _save_to_file(self, path):
        """Save workspace to file"""
        try:
            import json
            
            if not path:
                raise ValueError(self.lang.get('msg_no_save_path'))
            
            directory = os.path.dirname(path)
            if directory and not os.path.exists(directory):
                os.makedirs(directory, exist_ok=True)
            
            workspace_data = {
                'saved_palettes': self.saved_palettes or [],
                'selected_schemes': self.selected_schemes or [],
                'source_type': self.source_type.get() if hasattr(self, 'source_type') else 'hex',
                'hex_entry': self.hex_entry.get() if hasattr(self, 'hex_entry') else '#3498db',
                'current_palettes': getattr(self, 'current_palettes', []),
                'saved_counter': self._saved_counter,
                'saved_selected': self._saved_selected,
                'version': '1.0'
            }
            
            data_json = json.dumps(workspace_data, ensure_ascii=False)
            encrypted = self._encrypt_aes(data_json)
            
            temp_path = path + '.tmp'
            try:
                with open(temp_path, 'wb') as f:
                    f.write(encrypted)
                
                if os.path.exists(path):
                    backup_path = path + '.bak'
                    if os.path.exists(backup_path):
                        os.remove(backup_path)
                    os.rename(path, backup_path)
                
                os.rename(temp_path, path)
                
                backup_path = path + '.bak'
                if os.path.exists(backup_path):
                    try:
                        os.remove(backup_path)
                    except Exception:
                        pass
                        
            except Exception as write_error:
                if os.path.exists(temp_path):
                    try:
                        os.remove(temp_path)
                    except Exception:
                        pass
                raise write_error
            
            self.current_file = path
            self.is_modified = False
            self.update_title()
            
            self.add_recent_file(path)
            messagebox.showinfo(self.lang.get('saved_title'), self.lang.get('msg_workspace_saved').format(path=path))
            return True
            
        except Exception as e:
            messagebox.showerror(self.lang.get('save_error_title'), self.lang.get('msg_save_failed').format(error=str(e)))
            return False

    def load_pgf(self):
        """Load workspace"""
        try:
            path = filedialog.askopenfilename(
                title=self.lang.get('dialog_open_pgf'),
                initialdir=os.getcwd(),
                filetypes=[('PGF file', '*.pgf')]
            )
            if not path:
                return
            
            self._load_pgf_from_path(path)
        except Exception as e:
            messagebox.showerror(self.lang.get('load_error_title'), self.lang.get('msg_load_failed').format(error=str(e)))
    
    def _load_pgf_from_path(self, path):
        """Load workspace from specific path"""
        import json
        import base64
        
        with open(path, 'rb') as f:
            file_data = f.read()
        
        try:
            data_json = self._decrypt_aes(file_data)
            workspace_data = json.loads(data_json)
        except Exception:
            try:
                data_json = base64.b64decode(file_data).decode('utf-8')
                workspace_data = json.loads(data_json)
            except Exception as e2:
                raise Exception(f"Failed to decrypt file: {str(e2)}")
        
        self.saved_palettes = workspace_data.get('saved_palettes', [])
        self.selected_schemes = workspace_data.get('selected_schemes', ['complementary', 'analogous', 'triadic', 'monochromatic'])
        self.source_type.set(workspace_data.get('source_type', 'hex'))
        self.hex_entry.set(workspace_data.get('hex_entry', '#3498db'))
        self.current_palettes = workspace_data.get('current_palettes', [])
        self._saved_counter = workspace_data.get('saved_counter', 0)
        self._saved_selected = workspace_data.get('saved_selected', None)
        
        self._update_color_swatch(self.hex_entry.get())
        self.on_source_change()
        self.render_saved_list()
        
        if self.current_palettes:
            self.clear_palette_display()
            source_type = self.source_type.get()
            if source_type == 'hex' and self.current_palettes:
                self.display_single_palette(self.current_palettes[0])
            elif source_type == 'image' and self.current_palettes:
                self.display_multiple_palettes(self.current_palettes)
        
        self.current_file = path
        self.is_modified = False
        self.update_title()
        
        self.add_recent_file(path)
        messagebox.showinfo(self.lang.get('loaded_title'), self.lang.get('msg_workspace_loaded').format(path=path))
        self.log_action(f"Loaded workspace: {path}")

    # ============== Encryption ==============
    def _get_encryption_key(self):
        """Generate encryption key"""
        passphrase = "ColorPaletteGenerator2025SecretKey"
        key = hashlib.sha256(passphrase.encode()).digest()
        import base64
        return base64.urlsafe_b64encode(key)
    
    def _encrypt_aes(self, data):
        """Encrypt data"""
        key = self._get_encryption_key()
        f = Fernet(key)
        return f.encrypt(data.encode('utf-8'))
    
    def _decrypt_aes(self, encrypted_data):
        """Decrypt data"""
        key = self._get_encryption_key()
        f = Fernet(key)
        return f.decrypt(encrypted_data).decode('utf-8')

    # ============== Recent Files ==============
    def get_temp_dir(self):
        """Get temp directory"""
        import sys
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(__file__)
        
        temp_dir = os.path.join(base_dir, 'temp')
        os.makedirs(temp_dir, exist_ok=True)
        return temp_dir
    
    def get_recent_files_path(self):
        """Get recent files path"""
        return os.path.join(self.get_temp_dir(), 'recent.dat')
    
    def load_recent_files(self):
        """Load recent files"""
        try:
            import json
            
            path = self.get_recent_files_path()
            if not os.path.exists(path):
                return []
            
            with open(path, 'rb') as f:
                encrypted = f.read()
            
            data = self._decrypt_aes(encrypted)
            recent_files = json.loads(data)
            
            return [f for f in recent_files if os.path.exists(f)]
        except Exception:
            return []
    
    def save_recent_files(self, recent_files):
        """Save recent files"""
        try:
            import json
            
            data = json.dumps(recent_files)
            encrypted = self._encrypt_aes(data)
            
            path = self.get_recent_files_path()
            with open(path, 'wb') as f:
                f.write(encrypted)
        except Exception:
            pass
    
    def add_recent_file(self, filepath):
        """Add to recent files"""
        recent_files = self.load_recent_files()
        
        if filepath in recent_files:
            recent_files.remove(filepath)
        
        recent_files.insert(0, filepath)
        recent_files = recent_files[:10]
        
        self.save_recent_files(recent_files)
    
    def load_recent_file(self, filepath):
        """Load recent file"""
        if not os.path.exists(filepath):
            messagebox.showerror(self.lang.get('error'), self.lang.get('msg_file_not_found_path').format(path=filepath))
            return
        
        try:
            self._load_pgf_from_path(filepath)
        except Exception as e:
            messagebox.showerror(self.lang.get('load_error_title'), self.lang.get('msg_load_failed').format(error=str(e)))

    # ============== Utility Functions ==============
    def update_title(self):
        """Update window title"""
        base_title = self.lang.get('title')
        if self.current_file:
            filename = os.path.basename(self.current_file)
            title = f"{base_title} - {filename}"
        else:
            title = f"{base_title} - {self.lang.get('untitled')}"
        
        if self.is_modified:
            title += " *"
        
        self.title(title)
        self.update_menu_states()
    
    def update_menu_states(self):
        """Update button states"""
        try:
            if hasattr(self, 'btn_delete'):
                if len(self.saved_palettes) <= 1 or self._saved_selected is None:
                    self.btn_delete.configure(state='disabled')
                else:
                    self.btn_delete.configure(state='normal')
        except Exception:
            pass

    def mark_modified(self):
        """Mark workspace as modified"""
        if not self.is_modified:
            self.is_modified = True
            self.update_title()

    def create_tooltip(self, widget, text):
        """Create tooltip with delayed show and proper after_cancel - main.py style"""
        tooltip_window = [None]
        show_after_id = [None]
        
        def destroy_tooltip():
            if tooltip_window[0] is not None:
                try:
                    if tooltip_window[0] in self.active_tooltips:
                        self.active_tooltips.remove(tooltip_window[0])
                    tooltip_window[0].destroy()
                except Exception:
                    pass
                tooltip_window[0] = None
        
        def show_tooltip(x_root, y_root):
            destroy_tooltip()
            tip = ctk.CTkToplevel(self)
            tip.wm_overrideredirect(True)
            try:
                tip.wm_attributes('-topmost', True)
            except Exception:
                pass
            tip.wm_geometry(f"+{x_root + 10}+{y_root + 10}")
            tip.configure(fg_color=COLORS['bg_card'])
            
            label = ctk.CTkLabel(
                tip,
                text=text,
                font=ctk.CTkFont(family=FONT_FAMILY, size=10),
                text_color=COLORS['text_primary']
            )
            label.pack(padx=8, pady=4)
            tooltip_window[0] = tip
            self.active_tooltips.append(tip)
        
        def on_enter(e):
            if show_after_id[0] is not None:
                try:
                    widget.after_cancel(show_after_id[0])
                except Exception:
                    pass
                show_after_id[0] = None
            
            show_after_id[0] = widget.after(120, lambda: show_tooltip(e.x_root, e.y_root))
        
        def on_leave(e):
            if show_after_id[0] is not None:
                try:
                    widget.after_cancel(show_after_id[0])
                except Exception:
                    pass
                show_after_id[0] = None
            destroy_tooltip()
        
        def on_motion(e):
            if tooltip_window[0] is not None:
                try:
                    tooltip_window[0].wm_geometry(f"+{e.x_root + 10}+{e.y_root + 10}")
                except Exception:
                    pass
        
        widget.bind('<Enter>', on_enter)
        widget.bind('<Leave>', on_leave)
        widget.bind('<Motion>', on_motion)

    def setup_logging(self):
        """Setup logging"""
        import sys
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(__file__)
        
        temp_dir = os.path.join(base_dir, 'temp')
        os.makedirs(temp_dir, exist_ok=True)
        log_file = os.path.join(temp_dir, 'app.log')
        
        logger = logging.getLogger()
        logger.handlers.clear()
        logger.setLevel(logging.INFO)
        
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        
        self.logger = logger
        self.logger.info("="*50)
        self.logger.info("Logging system initialized")
    
    def _init_preset_palettes_async(self):
        """Initialize preset palettes in background"""
        try:
            preset_file = os.path.join('data', 'preset_palettes.dat')
            if os.path.exists(preset_file):
                return
            
            logging.info("Preset palettes not found. Generating in background...")
            
            import threading
            
            def generate_presets():
                try:
                    from preset_generator import PresetPaletteGenerator
                    generator = PresetPaletteGenerator()
                    palettes = generator.generate_all_palettes(count=1200)
                    generator.save_palettes(self.file_handler, 'preset_palettes.dat')
                    logging.info(f"Successfully generated {len(palettes)} preset palettes")
                except Exception as e:
                    logging.error(f"Failed to generate preset palettes: {e}")
            
            thread = threading.Thread(target=generate_presets, daemon=True)
            thread.start()
            
        except Exception as e:
            logging.error(f"Error initializing preset palettes: {e}")
    
    def log_action(self, action):
        """Log an action"""
        try:
            if hasattr(self, 'logger'):
                self.logger.info(action)
        except Exception:
            pass
    
    def bind_shortcuts(self):
        """Setup keyboard shortcuts"""
        self.bind('<Control-s>', lambda e: self.save_pgf())
        self.bind('<Control-Shift-S>', lambda e: self.save_pgf_as())
        self.bind('<Control-n>', lambda e: self.new_pgf())
        self.bind('<Control-o>', lambda e: self.load_pgf())
        self.bind('<Delete>', lambda e: self.remove_saved_palette())
        self.bind('<F5>', lambda e: self.generate())
        self.log_action("Keyboard shortcuts enabled")
    
    def setup_drag_drop(self):
        """Setup drag and drop"""
        try:
            def on_drop(event):
                files = self.tk.splitlist(event.data)
                if files:
                    file_path = files[0]
                    if file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp')):
                        self.image_path = file_path
                        self.source_type.set('image')
                        self.on_source_change()
                        self.log_action(f"Image dropped: {os.path.basename(file_path)}")
                    elif file_path.lower().endswith('.pgf'):
                        self._load_pgf_from_path(file_path)
            
            self.drop_target_register('DND_Files')
            self.dnd_bind('<<Drop>>', on_drop)
        except Exception:
            pass
    
    def start_auto_save(self):
        """Start auto-save timer"""
        if self.auto_save_enabled and self.is_modified and self.current_file:
            try:
                self._save_to_file(self.current_file)
                self.log_action("Auto-saved workspace")
            except Exception as e:
                self.log_action(f"Auto-save failed: {str(e)}")
        
        if self.auto_save_enabled:
            self.auto_save_timer = self.after(self.auto_save_interval, self.start_auto_save)
    
    def stop_auto_save(self):
        """Stop auto-save timer"""
        if self.auto_save_timer:
            self.after_cancel(self.auto_save_timer)
            self.auto_save_timer = None
    
    def on_closing(self):
        """Handle window close"""
        self.stop_auto_save()
        
        if self.is_modified:
            response = messagebox.askyesnocancel(
                self.lang.get('save_prompt_title'),
                self.lang.get('msg_save_changes_prompt'),
            )
            if response is None:
                return
            elif response:
                saved = self.save_pgf()
                if not saved:
                    return
        
        self.log_action("Application closed")
        self.destroy()

    # ============== Stub methods for features to be implemented ==============
    def rename_palette(self, idx):
        """Rename palette"""
        try:
            entry = self.saved_palettes[idx]
            old_name = entry['name']
            
            dialog = ctk.CTkInputDialog(
                text=f"{self.lang.get('new_name')}:",
                title=self.lang.get('rename')
            )
            new_name = dialog.get_input()
            
            if new_name:
                self.saved_palettes[idx]['name'] = new_name
                self.render_saved_list()
                self.mark_modified()
                self.log_action(f"Renamed palette: {old_name} -> {new_name}")
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), str(e))

    def open_palette_editor(self, idx):
        """Open palette editor dialog with full functionality"""
        if idx is None or idx >= len(self.saved_palettes):
            return
        
        entry = self.saved_palettes[idx]
        
        dialog = ctk.CTkToplevel(self)
        set_window_icon(dialog)
        dialog.title(self.lang.get('palette_editor_title').format(name=entry['name']))
        dialog.geometry("600x500")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(fg_color=COLORS['bg_dark'])
        
        # Header
        header_frame = ctk.CTkFrame(dialog, fg_color=COLORS['bg_secondary'], height=50)
        header_frame.pack(fill='x', padx=0, pady=0)
        header_frame.pack_propagate(False)
        
        ctk.CTkLabel(
            header_frame,
            text=f" {entry['name']}",
            image=self._get_icon('palette'),
            compound='left',
            font=ctk.CTkFont(family=FONT_FAMILY, size=16, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(side='left', padx=15, pady=10)
        
        color_count_label = ctk.CTkLabel(
            header_frame,
            text=self.lang.get('colors_count').format(count=len(entry['colors'])),
            font=ctk.CTkFont(family=FONT_FAMILY, size=11),
            text_color=COLORS['text_secondary']
        )
        color_count_label.pack(side='right', padx=15, pady=10)
        
        # Toolbar
        toolbar = ctk.CTkFrame(dialog, fg_color="transparent")
        toolbar.pack(fill='x', padx=15, pady=10)
        
        # Local copy of colors for editing
        edit_colors = entry['colors'].copy()
        selected_color_idx = [None]
        
        # Color list frame (create before refresh_color_list)
        color_list_frame = ctk.CTkScrollableFrame(dialog, fg_color=COLORS['bg_card'])
        color_list_frame.pack(fill='both', expand=True, padx=15, pady=10)
        
        def refresh_color_list():
            for widget in color_list_frame.winfo_children():
                widget.destroy()
            
            color_count_label.configure(text=self.lang.get('colors_count').format(count=len(edit_colors)))
            
            for i, color in enumerate(edit_colors):
                is_selected = selected_color_idx[0] == i
                
                color_row = ctk.CTkFrame(
                    color_list_frame,
                    fg_color=COLORS['accent'] if is_selected else COLORS['bg_secondary'],
                    corner_radius=6,
                    height=45
                )
                color_row.pack(fill='x', pady=2)
                color_row.pack_propagate(False)
                
                # Color swatch
                swatch = ctk.CTkFrame(
                    color_row,
                    width=40,
                    height=35,
                    corner_radius=4,
                    fg_color=color
                )
                swatch.pack(side='left', padx=10, pady=5)
                swatch.pack_propagate(False)
                
                # Color info
                info_frame = ctk.CTkFrame(color_row, fg_color="transparent")
                info_frame.pack(side='left', fill='both', expand=True, padx=10)
                
                hex_lbl = ctk.CTkLabel(
                    info_frame,
                    text=color.upper(),
                    font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
                    text_color=COLORS['text_primary']
                )
                hex_lbl.pack(anchor='w')
                
                try:
                    rgb = self.generator.hex_to_rgb(color)
                    rgb_lbl = ctk.CTkLabel(
                        info_frame,
                        text=f"RGB({rgb[0]}, {rgb[1]}, {rgb[2]})",
                        font=ctk.CTkFont(family=FONT_FAMILY, size=10),
                        text_color=COLORS['text_secondary']
                    )
                    rgb_lbl.pack(anchor='w')
                except Exception:
                    pass
                
                # Select on click
                def make_select(color_idx):
                    def handler(e=None):
                        selected_color_idx[0] = color_idx
                        refresh_color_list()
                    return handler
                
                for w in [color_row, swatch, info_frame, hex_lbl]:
                    w.bind('<Button-1>', make_select(i))
                    try:
                        w.configure(cursor='hand2')
                    except Exception:
                        pass
        
        # Add color button
        def add_color():
            color_result = colorchooser.askcolor(title=self.lang.get('add_color_title'))
            if color_result[1]:
                edit_colors.append(color_result[1])
                refresh_color_list()
        
        ModernButton(toolbar, text=f"‚ûï {self.lang.get('add_color')}", command=add_color, width=100).pack(side='left', padx=2)
        
        # Edit color button
        def edit_selected_color():
            if selected_color_idx[0] is None:
                messagebox.showinfo(self.lang.get('selection_required'), self.lang.get('select_color_first'))
                return
            current_color = edit_colors[selected_color_idx[0]]
            color_result = colorchooser.askcolor(color=current_color, title=self.lang.get('edit_color_title'))
            if color_result[1]:
                edit_colors[selected_color_idx[0]] = color_result[1]
                refresh_color_list()
        
        ModernSecondaryButton(toolbar, text=f"‚úèÔ∏è {self.lang.get('edit')}", command=edit_selected_color, width=80).pack(side='left', padx=2)
        
        # Delete color button
        def delete_selected_color():
            if selected_color_idx[0] is None:
                messagebox.showinfo(self.lang.get('selection_required'), self.lang.get('select_color_first'))
                return
            del edit_colors[selected_color_idx[0]]
            selected_color_idx[0] = None
            refresh_color_list()
        
        ModernSecondaryButton(toolbar, text=f" {self.lang.get('delete')}", image=self._get_icon('delete'), compound='left', command=delete_selected_color, width=80).pack(side='left', padx=2)
        
        # Move buttons
        def move_up():
            if selected_color_idx[0] is None or selected_color_idx[0] == 0:
                return
            i = selected_color_idx[0]
            edit_colors[i], edit_colors[i-1] = edit_colors[i-1], edit_colors[i]
            selected_color_idx[0] = i - 1
            refresh_color_list()
        
        def move_down():
            if selected_color_idx[0] is None or selected_color_idx[0] >= len(edit_colors) - 1:
                return
            i = selected_color_idx[0]
            edit_colors[i], edit_colors[i+1] = edit_colors[i+1], edit_colors[i]
            selected_color_idx[0] = i + 1
            refresh_color_list()
        
        ModernIconButton(toolbar, text="\u2b06\ufe0f", command=move_up, width=36).pack(side='left', padx=2)
        ModernIconButton(toolbar, text="\u2b07\ufe0f", command=move_down, width=36).pack(side='left', padx=2)
        
        # Sort buttons
        sort_frame = ctk.CTkFrame(toolbar, fg_color="transparent")
        sort_frame.pack(side='right')
        
        def sort_by_hue():
            def get_hue(hex_color):
                rgb = self.generator.hex_to_rgb(hex_color)
                h, s, v = colorsys.rgb_to_hsv(rgb[0]/255, rgb[1]/255, rgb[2]/255)
                return h
            edit_colors.sort(key=get_hue)
            refresh_color_list()
        
        def sort_by_saturation():
            def get_saturation(hex_color):
                rgb = self.generator.hex_to_rgb(hex_color)
                h, s, v = colorsys.rgb_to_hsv(rgb[0]/255, rgb[1]/255, rgb[2]/255)
                return s
            edit_colors.sort(key=get_saturation, reverse=True)
            refresh_color_list()
        
        def sort_by_value():
            def get_value(hex_color):
                rgb = self.generator.hex_to_rgb(hex_color)
                return 0.299*rgb[0] + 0.587*rgb[1] + 0.114*rgb[2]
            edit_colors.sort(key=get_value)
            refresh_color_list()
        
        ModernSecondaryButton(sort_frame, text=self.lang.get('sort_by_hue'), command=sort_by_hue, width=70).pack(side='left', padx=2)
        ModernSecondaryButton(sort_frame, text=self.lang.get('sort_by_saturation'), command=sort_by_saturation, width=70).pack(side='left', padx=2)
        ModernSecondaryButton(sort_frame, text=self.lang.get('sort_by_luminance'), command=sort_by_value, width=70).pack(side='left', padx=2)
        
        refresh_color_list()
        
        # Bottom buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill='x', padx=15, pady=15)
        
        def save_changes():
            entry['colors'] = edit_colors.copy()
            self.render_saved_list()
            self.mark_modified()
            self.log_action(f"Updated palette: {entry['name']}")
            dialog.destroy()
        
        ModernButton(btn_frame, text=self.lang.get('button_save'), command=save_changes, width=100).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('button_cancel'), command=dialog.destroy, width=100).pack(side='left', padx=5)

    def save_palette_file(self, idx):
        """Save palette file"""
        try:
            entry = self.saved_palettes[idx]
            filename = filedialog.asksaveasfilename(
                defaultextension='.mps',
                filetypes=[(self.lang.get('my_palette_file'), '*.mps'), (self.lang.get('all_files'), '*.*')],
                initialfile=entry['name']
            )
            if filename:
                import json
                import base64
                data = json.dumps({'name': entry['name'], 'colors': entry['colors']})
                encoded = base64.b64encode(data.encode('utf-8')).decode('utf-8')
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(encoded)
                
                self.file_handler.add_palette_metadata(entry['name'], entry['colors'], filename)
                self.log_action(f"Saved palette to MPS: {entry['name']}")
        except Exception as e:
            messagebox.showerror(self.lang.get('save_error_title'), self.lang.get('msg_save_failed').format(error=str(e)))

    def toggle_palette_view(self, idx):
        """Toggle palette view mode"""
        try:
            entry = self.saved_palettes[idx]
            current_mode = entry.get('view_mode', 'rgb')
            entry['view_mode'] = 'value' if current_mode == 'rgb' else 'rgb'
            self.render_saved_list()
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), str(e))

    def export_palette_txt(self, idx):
        """Export palette to TXT"""
        try:
            entry = self.saved_palettes[idx]
            colors = entry.get('colors', [])
            if not colors:
                messagebox.showinfo(self.lang.get('export_title'), self.lang.get('msg_palette_has_no_colors'))
                return
            
            filename = filedialog.asksaveasfilename(
                defaultextension='.txt',
                filetypes=[(self.lang.get('text_file'), '*.txt'), (self.lang.get('all_files'), '*.*')],
                initialfile=f"{entry['name']}.txt"
            )
            if filename:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(f"Palette: {entry['name']}\n")
                    f.write(f"Colors: {len(colors)}\n\n")
                    for i, color in enumerate(colors, 1):
                        f.write(f"{i}. {color}\n")
                messagebox.showinfo(self.lang.get('saved_title'), f"Exported to {filename}")
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), str(e))

    def export_palette_png(self, idx):
        """Export palette to PNG"""
        try:
            entry = self.saved_palettes[idx]
            colors = entry.get('colors', [])
            if not colors:
                messagebox.showinfo(self.lang.get('export_title'), self.lang.get('msg_palette_has_no_colors'))
                return
            
            filename = filedialog.asksaveasfilename(
                defaultextension='.png',
                filetypes=[(self.lang.get('png_image'), '*.png'), (self.lang.get('all_files'), '*.*')],
                initialfile=f"{entry['name']}.png"
            )
            if filename:
                color_width = 100
                img_width = color_width * len(colors)
                img_height = 100
                
                img = Image.new('RGB', (img_width, img_height))
                draw = ImageDraw.Draw(img)
                
                for i, color in enumerate(colors):
                    x0 = i * color_width
                    x1 = x0 + color_width
                    draw.rectangle([x0, 0, x1, img_height], fill=color)
                
                img.save(filename)
                messagebox.showinfo(self.lang.get('saved_title'), f"Exported to {filename}")
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), str(e))

    def open_color_adjuster(self):
        """Open color adjuster dialog for the selected palette"""
        if self._saved_selected is None:
            messagebox.showinfo(self.lang.get('selection_required'), self.lang.get('select_palette_to_adjust'))
            return
        
        if not COLOR_ADJUSTER_AVAILABLE:
            messagebox.showwarning(self.lang.get('warning'), self.lang.get('msg_color_adjust_unavailable'))
            return
        
        entry = self.saved_palettes[self._saved_selected]
        colors = entry.get('colors', [])
        
        if not colors:
            messagebox.showinfo(self.lang.get('info'), self.lang.get('msg_palette_has_no_colors'))
            return
        
        dialog = ctk.CTkToplevel(self)
        set_window_icon(dialog)
        dialog.title(self.lang.get('color_adjuster_title'))
        dialog.geometry("500x400")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(fg_color=COLORS['bg_dark'])
        
        # Header
        ctk.CTkLabel(
            dialog,
            text=f" {self.lang.get('color_adjuster_title')} - {entry['name']}",
            image=self._get_icon('palette'),
            compound='left',
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(pady=15, padx=15, anchor='w')
        
        # Preview frame
        preview_frame = ctk.CTkFrame(dialog, fg_color=COLORS['bg_card'], height=60)
        preview_frame.pack(fill='x', padx=15, pady=10)
        preview_frame.pack_propagate(False)
        
        preview_colors = colors.copy()
        
        def update_preview():
            for widget in preview_frame.winfo_children():
                widget.destroy()
            for color in preview_colors:
                swatch = ctk.CTkFrame(
                    preview_frame,
                    fg_color=color,
                    corner_radius=4
                )
                swatch.pack(side='left', fill='both', expand=True, padx=2, pady=5)
        
        update_preview()
        
        # Contrast slider
        contrast_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        contrast_frame.pack(fill='x', padx=15, pady=10)
        
        ctk.CTkLabel(
            contrast_frame,
            text=self.lang.get('contrast'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12),
            text_color=COLORS['text_primary']
        ).pack(anchor='w')
        
        contrast_var = ctk.DoubleVar(value=0)
        contrast_slider = ctk.CTkSlider(
            contrast_frame,
            from_=-1.0,
            to=1.0,
            variable=contrast_var,
            fg_color=COLORS['bg_secondary'],
            progress_color=COLORS['accent'],
            button_color=COLORS['accent_light']
        )
        contrast_slider.pack(fill='x', pady=5)
        
        contrast_value_label = ctk.CTkLabel(
            contrast_frame,
            text="0%",
            font=ctk.CTkFont(family=FONT_FAMILY, size=10),
            text_color=COLORS['text_secondary']
        )
        contrast_value_label.pack(anchor='e')
        
        # Warmth slider
        warmth_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        warmth_frame.pack(fill='x', padx=15, pady=10)
        
        ctk.CTkLabel(
            warmth_frame,
            text=f"{self.lang.get('warmth')} {self.lang.get('warmth_hint')}",
            font=ctk.CTkFont(family=FONT_FAMILY, size=12),
            text_color=COLORS['text_primary']
        ).pack(anchor='w')
        
        warmth_var = ctk.DoubleVar(value=0)
        warmth_slider = ctk.CTkSlider(
            warmth_frame,
            from_=-1.0,
            to=1.0,
            variable=warmth_var,
            fg_color=COLORS['bg_secondary'],
            progress_color=COLORS['accent'],
            button_color=COLORS['accent_light']
        )
        warmth_slider.pack(fill='x', pady=5)
        
        warmth_value_label = ctk.CTkLabel(
            warmth_frame,
            text="0%",
            font=ctk.CTkFont(family=FONT_FAMILY, size=10),
            text_color=COLORS['text_secondary']
        )
        warmth_value_label.pack(anchor='e')
        
        def on_slider_change(*args):
            nonlocal preview_colors
            contrast = contrast_var.get()
            warmth = warmth_var.get()
            
            contrast_value_label.configure(text=f"{int(contrast * 100)}%")
            warmth_value_label.configure(text=f"{int(warmth * 100)}%")
            
            adjusted = []
            for color in colors:
                try:
                    rgb = self.generator.hex_to_rgb(color)
                    if apply_contrast and contrast != 0:
                        rgb = apply_contrast(rgb, contrast)
                    if apply_warmth and warmth != 0:
                        rgb = apply_warmth(rgb, warmth)
                    adjusted.append(self.generator.rgb_to_hex(rgb))
                except Exception:
                    adjusted.append(color)
            
            preview_colors = adjusted
            update_preview()
        
        contrast_var.trace_add('write', on_slider_change)
        warmth_var.trace_add('write', on_slider_change)
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill='x', padx=15, pady=20)
        
        def apply_changes():
            entry['colors'] = preview_colors.copy()
            self.render_saved_list()
            self.mark_modified()
            self.log_action(f"Applied color adjustments to: {entry['name']}")
            dialog.destroy()
        
        def reset_sliders():
            contrast_var.set(0)
            warmth_var.set(0)
        
        ModernButton(btn_frame, text=self.lang.get('apply'), command=apply_changes, width=100).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('reset'), command=reset_sliders, width=100).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('button_cancel'), command=dialog.destroy, width=100).pack(side='left', padx=5)

    def apply_palette_to_image(self):
        """Apply palette to image - opens the Image Recolorer dialog"""
        if not self.saved_palettes or all(len(p.get('colors', [])) == 0 for p in self.saved_palettes):
            messagebox.showinfo(self.lang.get('info'), self.lang.get('msg_no_valid_colors'))
            return
        
        dialog = ctk.CTkToplevel(self)
        set_window_icon(dialog)
        dialog.title(self.lang.get('dialog_apply_palette'))
        dialog.geometry("900x650")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(fg_color=COLORS['bg_dark'])
        
        # State
        current_image_path = [None]
        current_preview = [None]
        recolorer = ImageRecolorer()
        
        # Left panel - Controls
        left_panel = ctk.CTkFrame(dialog, fg_color=COLORS['bg_secondary'], width=280)
        left_panel.pack(side='left', fill='y', padx=0, pady=0)
        left_panel.pack_propagate(False)
        
        # Palette selection
        ctk.CTkLabel(
            left_panel,
            text=self.lang.get('recolor_select_palette'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(anchor='w', padx=15, pady=(15, 5))
        
        # Palette list
        palette_names = [p['name'] for p in self.saved_palettes if p.get('colors')]
        if not palette_names:
            palette_names = ['No palettes available']
        
        selected_palette_var = ctk.StringVar(value=palette_names[0] if palette_names else '')
        palette_combo = ctk.CTkComboBox(
            left_panel,
            values=palette_names,
            variable=selected_palette_var,
            fg_color=COLORS['bg_card'],
            button_color=COLORS['accent'],
            button_hover_color=COLORS['accent_hover'],
            width=250
        )
        palette_combo.pack(padx=15, pady=5)
        
        # Palette preview
        palette_preview_frame = ctk.CTkFrame(left_panel, fg_color=COLORS['bg_card'], height=40)
        palette_preview_frame.pack(fill='x', padx=15, pady=10)
        palette_preview_frame.pack_propagate(False)
        
        def update_palette_preview(*args):
            for widget in palette_preview_frame.winfo_children():
                widget.destroy()
            
            name = selected_palette_var.get()
            for p in self.saved_palettes:
                if p['name'] == name:
                    colors = p.get('colors', [])[:10]
                    if colors:
                        # Use Canvas for precise width calculation
                        canvas = tk.Canvas(
                            palette_preview_frame,
                            height=40,
                            bg=COLORS['bg_card'],
                            highlightthickness=0
                        )
                        canvas.pack(fill='both', expand=True)
                        
                        def draw_preview():
                            canvas.delete('all')
                            canvas.update_idletasks()
                            canvas_width = canvas.winfo_width()
                            if canvas_width <= 1:
                                canvas_width = 400
                            
                            box_width = float(canvas_width) / float(len(colors))
                            for i, color in enumerate(colors):
                                x1 = int(i * box_width)
                                x2 = int((i + 1) * box_width)
                                canvas.create_rectangle(x1, 0, x2, 40, fill=color, outline='')
                        
                        canvas.after(50, draw_preview)
                    break
        
        selected_palette_var.trace_add('write', update_palette_preview)
        update_palette_preview()
        
        # Separator
        ctk.CTkFrame(left_panel, height=1, fg_color=COLORS['border']).pack(fill='x', padx=15, pady=15)
        
        # Load image button
        def load_image():
            path = filedialog.askopenfilename(
                title=self.lang.get('dialog_select_image_recolor'),
                filetypes=[
                    (self.lang.get('image_files'), "*.png;*.jpg;*.jpeg;*.bmp;*.gif"),
                    (self.lang.get('all_files'), "*.*"),
                ]
            )
            if path:
                current_image_path[0] = path
                try:
                    img = Image.open(path)
                    # Resize for preview
                    max_size = (500, 400)
                    img.thumbnail(max_size, Image.Resampling.LANCZOS)
                    photo = ctk.CTkImage(light_image=img, dark_image=img, size=img.size)
                    image_label.configure(image=photo, text="")
                    image_label.image = photo
                    
                    # Show filename
                    file_label.configure(text=os.path.basename(path))
                except Exception as e:
                    messagebox.showerror(self.lang.get('error'), self.lang.get('msg_recolor_load_image_failed').format(error=str(e)))
        
        ModernButton(
            left_panel,
            text=f" {self.lang.get('recolor_load_image')}",
            image=self._get_icon('camera'),
            compound='left',
            command=load_image,
            width=250
        ).pack(padx=15, pady=5)
        
        file_label = ctk.CTkLabel(
            left_panel,
            text=self.lang.get('no_file_selected'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=10),
            text_color=COLORS['text_muted']
        )
        file_label.pack(anchor='w', padx=15)
        
        # Apply button
        def apply_recolor():
            if not current_image_path[0]:
                messagebox.showinfo(self.lang.get('info'), self.lang.get('msg_select_image_first'))
                return
            
            name = selected_palette_var.get()
            colors = []
            for p in self.saved_palettes:
                if p['name'] == name:
                    colors = p.get('colors', [])
                    break
            
            if not colors:
                messagebox.showinfo(self.lang.get('info'), self.lang.get('msg_palette_has_no_colors'))
                return
            
            try:
                result_img = recolorer.apply_palette_to_image(current_image_path[0], colors)
                current_preview[0] = result_img
                
                # Show preview
                preview = result_img.copy()
                max_size = (500, 400)
                preview.thumbnail(max_size, Image.Resampling.LANCZOS)
                photo = ctk.CTkImage(light_image=preview, dark_image=preview, size=preview.size)
                image_label.configure(image=photo, text="")
                image_label.image = photo
                
                self.log_action(f"Applied palette to image: {os.path.basename(current_image_path[0])}")
            except Exception as e:
                messagebox.showerror(self.lang.get('error'), self.lang.get('msg_recolor_preview_failed').format(error=str(e)))
        
        ModernButton(
            left_panel,
            text=f" {self.lang.get('apply')}",
            image=self._get_icon('palette'),
            compound='left',
            command=apply_recolor,
            width=250
        ).pack(padx=15, pady=15)
        
        # Save button
        def save_result():
            if not current_preview[0]:
                messagebox.showinfo(self.lang.get('info'), self.lang.get('msg_no_preview'))
                return
            
            save_path = filedialog.asksaveasfilename(
                title=self.lang.get('dialog_save_recolored'),
                defaultextension='.png',
                filetypes=[(self.lang.get('png_image'), '*.png'), (self.lang.get('all_files'), '*.*')]
            )
            if save_path:
                try:
                    current_preview[0].save(save_path)
                    messagebox.showinfo(self.lang.get('saved_title'), self.lang.get('msg_recolor_save_success').format(path=save_path))
                except Exception as e:
                    messagebox.showerror(self.lang.get('error'), self.lang.get('msg_recolor_save_failed').format(error=str(e)))
        
        ModernSecondaryButton(
            left_panel,
            text=f"üíæ {self.lang.get('save_btn')}",
            command=save_result,
            width=250
        ).pack(padx=15, pady=5)
        
        # Close button
        ModernSecondaryButton(
            left_panel,
            text=self.lang.get('close_btn'),
            command=dialog.destroy,
            width=250
        ).pack(padx=15, pady=5)
        
        # Right panel - Image preview
        right_panel = ctk.CTkFrame(dialog, fg_color=COLORS['bg_card'])
        right_panel.pack(side='right', fill='both', expand=True, padx=10, pady=10)
        
        ctk.CTkLabel(
            right_panel,
            text=self.lang.get('recolor_preview'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(anchor='w', padx=15, pady=10)
        
        image_label = ctk.CTkLabel(
            right_panel,
            text=self.lang.get('no_image_label'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=12),
            text_color=COLORS['text_muted']
        )
        image_label.pack(expand=True, padx=20, pady=20)

    def open_custom_harmony(self):
        """Open custom harmony editor"""
        try:
            from custom_harmony import CustomHarmonyManager
            import colorsys
            from tkinter import colorchooser
            
            # Get current base color
            current_color = self.hex_entry.get() or '#FF0000'
            manager = CustomHarmonyManager(self.file_handler)
            
            dialog = ctk.CTkToplevel(self)
            set_window_icon(dialog)
            dialog.title(self.lang.get('dialog_custom_harmony'))
            dialog.geometry("1000x700")
            dialog.transient(self)
            dialog.grab_set()
            dialog.configure(fg_color=COLORS['bg_dark'])
            
            # State variables
            current_harmony_idx = [None]
            colors_list = []
            
            # Main layout
            main_content = ctk.CTkFrame(dialog, fg_color="transparent")
            main_content.pack(fill='both', expand=True, padx=15, pady=15)
            main_content.grid_columnconfigure(0, weight=1)
            main_content.grid_columnconfigure(1, weight=2)
            main_content.grid_rowconfigure(0, weight=1)
            
            # Left panel - Harmony list
            left_panel = ctk.CTkFrame(main_content, fg_color=COLORS['bg_card'], corner_radius=10)
            left_panel.grid(row=0, column=0, sticky='nsew', padx=(0, 10))
            
            ctk.CTkLabel(
                left_panel,
                text=self.lang.get('saved_harmonies'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=13, weight="bold"),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=15, pady=(15, 10))
            
            # Harmony listbox
            harmony_frame = ctk.CTkScrollableFrame(left_panel, fg_color=COLORS['bg_secondary'], height=400)
            harmony_frame.pack(fill='both', expand=True, padx=10, pady=5)
            
            harmony_buttons = []
            selected_harmony = [None]
            
            def load_harmony_list():
                for btn in harmony_buttons:
                    btn.destroy()
                harmony_buttons.clear()
                
                for i, harmony in enumerate(manager.harmonies):
                    def make_select(idx):
                        return lambda: on_harmony_select(idx)
                    
                    btn = ctk.CTkButton(
                        harmony_frame,
                        text=harmony.get('name', self.lang.get('unnamed')),
                        command=make_select(i),
                        fg_color=COLORS['bg_hover'],
                        hover_color=COLORS['accent'],
                        anchor='w',
                        height=32
                    )
                    btn.pack(fill='x', pady=2)
                    harmony_buttons.append(btn)
            
            def on_harmony_select(idx):
                selected_harmony[0] = idx
                current_harmony_idx[0] = idx
                harmony = manager.harmonies[idx]
                
                name_var.set(harmony.get('name', ''))
                colors_list.clear()
                colors_list.extend(harmony.get('colors', []))
                update_colors_display()
                update_preview()
                
                # Highlight selected
                for i, btn in enumerate(harmony_buttons):
                    if i == idx:
                        btn.configure(fg_color=COLORS['accent'])
                    else:
                        btn.configure(fg_color=COLORS['bg_hover'])
            
            # Harmony list buttons
            btn_toolbar = ctk.CTkFrame(left_panel, fg_color="transparent")
            btn_toolbar.pack(fill='x', padx=10, pady=10)
            
            def new_harmony():
                current_harmony_idx[0] = None
                name_var.set(self.lang.get('new_harmony'))
                colors_list.clear()
                update_colors_display()
                update_preview()
                for btn in harmony_buttons:
                    btn.configure(fg_color=COLORS['bg_hover'])
            
            def delete_harmony():
                if selected_harmony[0] is None:
                    messagebox.showwarning(self.lang.get('warning'), self.lang.get('custom_harmony_select_delete'))
                    return
                
                if messagebox.askyesno(self.lang.get('confirm'), self.lang.get('custom_harmony_confirm_delete')):
                    manager.delete_harmony(selected_harmony[0])
                    load_harmony_list()
                    new_harmony()
            
            ModernButton(btn_toolbar, text=self.lang.get('new_harmony'), command=new_harmony, height=32).pack(side='left', padx=2, expand=True, fill='x')
            ModernSecondaryButton(btn_toolbar, text=self.lang.get('delete_harmony'), command=delete_harmony, height=32).pack(side='left', padx=2, expand=True, fill='x')
            
            # Right panel - Editor
            right_panel = ctk.CTkFrame(main_content, fg_color=COLORS['bg_card'], corner_radius=10)
            right_panel.grid(row=0, column=1, sticky='nsew')
            
            # Name entry
            name_frame = ctk.CTkFrame(right_panel, fg_color="transparent")
            name_frame.pack(fill='x', padx=15, pady=(15, 10))
            
            ctk.CTkLabel(
                name_frame,
                text=self.lang.get('harmony_name'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12),
                text_color=COLORS['text_secondary']
            ).pack(side='left')
            
            name_var = ctk.StringVar(value="")
            ctk.CTkEntry(
                name_frame,
                textvariable=name_var,
                width=300,
                fg_color=COLORS['bg_secondary'],
                border_width=0
            ).pack(side='left', padx=10)
            
            # Colors section
            colors_section = ctk.CTkFrame(right_panel, fg_color=COLORS['bg_secondary'], corner_radius=8)
            colors_section.pack(fill='both', expand=True, padx=15, pady=10)
            
            ctk.CTkLabel(
                colors_section,
                text=self.lang.get('colors'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=10, pady=(10, 5))
            
            # Colors listbox
            colors_frame = ctk.CTkScrollableFrame(colors_section, fg_color=COLORS['bg_card'], height=200)
            colors_frame.pack(fill='both', expand=True, padx=10, pady=5)
            
            colors_labels = []
            
            def update_colors_display():
                for lbl in colors_labels:
                    lbl.destroy()
                colors_labels.clear()
                
                for i, color_data in enumerate(colors_list):
                    if color_data.get('type') == 'hsv':
                        h = color_data.get('h_offset', 0)
                        s = color_data.get('s_offset', 0)
                        v = color_data.get('v_offset', 0)
                        text = self.lang.get('custom_harmony_hsv_item').format(i=i + 1, h=h, s=s, v=v)
                    else:
                        hex_color = color_data.get('color', '#FFFFFF')
                        text = self.lang.get('custom_harmony_fixed_item').format(i=i + 1, hex=hex_color)
                    
                    lbl = ctk.CTkLabel(
                        colors_frame,
                        text=text,
                        font=ctk.CTkFont(family=FONT_FAMILY, size=11),
                        text_color=COLORS['text_primary'],
                        anchor='w'
                    )
                    lbl.pack(fill='x', pady=2)
                    colors_labels.append(lbl)
            
            # Color control buttons
            colors_btn_frame = ctk.CTkFrame(colors_section, fg_color="transparent")
            colors_btn_frame.pack(fill='x', padx=10, pady=10)
            
            def add_hsv_color():
                open_hsv_dialog(None, None)
            
            def add_fixed_color():
                color = colorchooser.askcolor(title=self.lang.get('add_fixed_color'))
                if color and color[1]:
                    colors_list.append({'type': 'fixed', 'color': color[1]})
                    update_colors_display()
                    update_preview()
            
            def open_hsv_dialog(edit_index, existing_data):
                is_edit = edit_index is not None
                hsv_dlg = ctk.CTkToplevel(dialog)
                set_window_icon(hsv_dlg)
                hsv_dlg.title(self.lang.get('edit') if is_edit else self.lang.get('add_hsv_color'))
                hsv_dlg.geometry('550x500')
                hsv_dlg.transient(dialog)
                hsv_dlg.grab_set()
                hsv_dlg.configure(fg_color=COLORS['bg_dark'])
                
                main = ctk.CTkFrame(hsv_dlg, fg_color=COLORS['bg_card'])
                main.pack(fill='both', expand=True, padx=20, pady=20)
                
                h_val = (existing_data or {}).get('h_offset', 0)
                s_val = (existing_data or {}).get('s_offset', 0)
                v_val = (existing_data or {}).get('v_offset', 0)
                
                h_var = ctk.DoubleVar(value=h_val)
                s_var = ctk.DoubleVar(value=s_val)
                v_var = ctk.DoubleVar(value=v_val)
                
                # Create sliders
                def create_slider(parent, label_text, var, min_val, max_val, unit):
                    frame = ctk.CTkFrame(parent, fg_color="transparent")
                    frame.pack(fill='x', pady=10)
                    
                    label_row = ctk.CTkFrame(frame, fg_color="transparent")
                    label_row.pack(fill='x', pady=(0, 5))
                    
                    ctk.CTkLabel(
                        label_row,
                        text=label_text,
                        font=ctk.CTkFont(family=FONT_FAMILY, size=12, weight="bold"),
                        text_color=COLORS['text_primary']
                    ).pack(side='left')
                    
                    value_label = ctk.CTkLabel(
                        label_row,
                        text="",
                        font=ctk.CTkFont(family=FONT_FAMILY, size=11),
                        text_color=COLORS['text_secondary']
                    )
                    value_label.pack(side='right')
                    
                    slider = ctk.CTkSlider(
                        frame,
                        from_=min_val,
                        to=max_val,
                        variable=var,
                        button_color=COLORS['accent'],
                        button_hover_color=COLORS['accent_hover'],
                        progress_color=COLORS['accent']
                    )
                    slider.pack(fill='x')
                    
                    def update_label(*args):
                        if unit == '¬∞':
                            value_label.configure(text=f"{var.get():.0f}{unit}")
                        else:
                            value_label.configure(text=f"{var.get():+.0f}{unit}")
                    
                    var.trace('w', update_label)
                    update_label()
                
                create_slider(main, self.lang.get('hue'), h_var, -180, 180, '¬∞')
                create_slider(main, self.lang.get('saturation'), s_var, -100, 100, '%')
                create_slider(main, self.lang.get('value'), v_var, -100, 100, '%')
                
                # Preview
                ctk.CTkLabel(
                    main,
                    text=self.lang.get('preview'),
                    font=ctk.CTkFont(family=FONT_FAMILY, size=11),
                    text_color=COLORS['text_secondary']
                ).pack(anchor='w', pady=(15, 5))
                
                preview_container = ctk.CTkFrame(main, height=60, fg_color=COLORS['bg_secondary'])
                preview_container.pack(fill='x', pady=(0, 15))
                preview_container.pack_propagate(False)
                
                preview = tk.Canvas(preview_container, height=60, bg=COLORS['bg_secondary'], highlightthickness=0)
                preview.pack(fill='both', expand=True)
                
                def update_hsv_preview(*args):
                    try:
                        base_rgb = self.generator.hex_to_rgb(current_color)
                        base_h, base_s, base_v = colorsys.rgb_to_hsv(base_rgb[0] / 255, base_rgb[1] / 255, base_rgb[2] / 255)
                        
                        new_h = (base_h + h_var.get() / 360) % 1.0
                        new_s = max(0, min(1, base_s + s_var.get() / 100))
                        new_v = max(0, min(1, base_v + v_var.get() / 100))
                        
                        rgb = colorsys.hsv_to_rgb(new_h, new_s, new_v)
                        hex_color = self.generator.rgb_to_hex(tuple(int(c * 255) for c in rgb))
                        
                        preview.delete('all')
                        preview.update_idletasks()
                        canvas_width = preview.winfo_width() or 450
                        preview.create_rectangle(0, 0, canvas_width, 60, fill=hex_color, outline='')
                    except Exception:
                        pass
                
                for var in (h_var, s_var, v_var):
                    var.trace('w', update_hsv_preview)
                preview.after(50, update_hsv_preview)
                
                # Buttons
                btns = ctk.CTkFrame(main, fg_color="transparent")
                btns.pack(pady=(10, 0))
                
                def confirm():
                    color_data = {'type': 'hsv', 'h_offset': h_var.get(), 's_offset': s_var.get(), 'v_offset': v_var.get()}
                    if is_edit:
                        colors_list[edit_index] = color_data
                    else:
                        colors_list.append(color_data)
                    update_colors_display()
                    update_preview()
                    hsv_dlg.destroy()
                
                ModernButton(btns, text=self.lang.get('ok'), command=confirm, width=100).pack(side='left', padx=5)
                ModernSecondaryButton(btns, text=self.lang.get('button_cancel'), command=hsv_dlg.destroy, width=100).pack(side='left', padx=5)
            
            ModernSecondaryButton(colors_btn_frame, text=self.lang.get('add_hsv_color'), command=add_hsv_color, height=28).pack(side='left', padx=2)
            ModernSecondaryButton(colors_btn_frame, text=self.lang.get('add_fixed_color'), command=add_fixed_color, height=28).pack(side='left', padx=2)
            
            # Preview section
            preview_section = ctk.CTkFrame(right_panel, fg_color=COLORS['bg_secondary'], corner_radius=8, height=100)
            preview_section.pack(fill='x', padx=15, pady=(0, 10))
            preview_section.pack_propagate(False)
            
            ctk.CTkLabel(
                preview_section,
                text=self.lang.get('preview'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=11),
                text_color=COLORS['text_secondary']
            ).pack(anchor='w', padx=10, pady=(10, 5))
            
            preview_canvas_frame = ctk.CTkFrame(preview_section, fg_color=COLORS['bg_card'])
            preview_canvas_frame.pack(fill='both', expand=True, padx=10, pady=(0, 10))
            
            preview_canvas = tk.Canvas(preview_canvas_frame, height=60, bg=COLORS['bg_card'], highlightthickness=0)
            preview_canvas.pack(fill='both', expand=True)
            
            def update_preview():
                preview_canvas.delete('all')
                if not colors_list:
                    return
                
                try:
                    temp_harmony = {'name': 'Preview', 'colors': colors_list}
                    temp_manager = CustomHarmonyManager(self.file_handler)
                    temp_manager.harmonies = [temp_harmony]
                    colors = temp_manager.apply_harmony(current_color, 0)
                    
                    if not colors:
                        return
                    
                    preview_canvas.update_idletasks()
                    canvas_width = preview_canvas.winfo_width() or 600
                    box_width = float(canvas_width) / float(len(colors))
                    for i, color in enumerate(colors):
                        x1 = int(i * box_width)
                        x2 = int((i + 1) * box_width)
                        preview_canvas.create_rectangle(x1, 0, x2, 60, fill=color, outline='')
                except Exception:
                    pass
            
            # Bottom buttons
            bottom_frame = ctk.CTkFrame(right_panel, fg_color="transparent")
            bottom_frame.pack(fill='x', padx=15, pady=(0, 15))
            
            def save_current_harmony():
                name = name_var.get().strip()
                if not name:
                    messagebox.showwarning(self.lang.get('warning'), self.lang.get('custom_harmony_name_required'))
                    return
                if not colors_list:
                    messagebox.showwarning(self.lang.get('warning'), self.lang.get('custom_harmony_color_required'))
                    return
                
                harmony_data = {'name': name, 'colors': colors_list.copy()}
                if current_harmony_idx[0] is not None:
                    manager.update_harmony(current_harmony_idx[0], harmony_data)
                else:
                    manager.add_harmony(harmony_data)
                
                load_harmony_list()
                messagebox.showinfo(self.lang.get('done'), self.lang.get('custom_harmony_saved'))
            
            ModernButton(bottom_frame, text=self.lang.get('button_save'), command=save_current_harmony, width=120).pack(side='left', padx=5)
            ModernSecondaryButton(bottom_frame, text=self.lang.get('button_close'), command=dialog.destroy, width=120).pack(side='right', padx=5)
            
            # Initialize
            load_harmony_list()
            
        except ImportError:
            messagebox.showerror(self.lang.get('error'), self.lang.get('custom_harmony_module_missing'))
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('custom_harmony_open_failed').format(error=str(e)))

    def open_ai_settings(self):
        """Open AI settings dialog"""
        try:
            from ai_color_recommender import AISettings
            
            dialog = ctk.CTkToplevel(self)
            set_window_icon(dialog)
            dialog.title(self.lang.get('dialog_ai_settings'))
            dialog.geometry("500x400")
            dialog.transient(self)
            dialog.grab_set()
            dialog.configure(fg_color=COLORS['bg_dark'])
            
            settings = AISettings.load_settings(self.file_handler)
            
            # Header
            ctk.CTkLabel(
                dialog,
                text=f"ÔøΩ {self.lang.get('settings_api')}",
                font=ctk.CTkFont(family=FONT_FAMILY, size=16, weight="bold"),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=15, pady=15)
            
            # Content
            content = ctk.CTkFrame(dialog, fg_color=COLORS['bg_card'])
            content.pack(fill='both', expand=True, padx=15, pady=5)
            
            # API Key
            ctk.CTkLabel(
                content,
                text=self.lang.get('ai_api_key_label'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=15, pady=(15, 5))
            
            api_key_var = ctk.StringVar(value=settings.get('api_key', ''))
            api_key_entry = ctk.CTkEntry(
                content,
                textvariable=api_key_var,
                width=400,
                fg_color=COLORS['bg_secondary'],
                show='*'
            )
            api_key_entry.pack(padx=15, pady=5)
            
            # Help text
            ctk.CTkLabel(
                content,
                text=self.lang.get('ai_api_help'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=10),
                text_color=COLORS['text_muted'],
                wraplength=400
            ).pack(anchor='w', padx=15, pady=5)
            
            # Number of colors per palette
            ctk.CTkLabel(
                content,
                text=self.lang.get('ai_colors_per_palette'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=15, pady=(15, 5))
            
            num_colors_var = ctk.IntVar(value=settings.get('num_colors', 5))
            num_colors_slider = ctk.CTkSlider(
                content,
                from_=3,
                to=10,
                number_of_steps=7,
                variable=num_colors_var,
                fg_color=COLORS['bg_secondary'],
                progress_color=COLORS['accent']
            )
            num_colors_slider.pack(fill='x', padx=15, pady=5)
            
            num_colors_label = ctk.CTkLabel(
                content,
                text=str(num_colors_var.get()),
                font=ctk.CTkFont(family=FONT_FAMILY, size=11),
                text_color=COLORS['text_secondary']
            )
            num_colors_label.pack(anchor='e', padx=15)
            
            def update_label(*args):
                num_colors_label.configure(text=str(int(num_colors_var.get())))
            num_colors_var.trace_add('write', update_label)
            
            # Keywords
            ctk.CTkLabel(
                content,
                text=self.lang.get('ai_keywords_label'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=15, pady=(15, 5))
            
            keywords_var = ctk.StringVar(value=settings.get('keywords', ''))
            keywords_entry = ctk.CTkEntry(
                content,
                textvariable=keywords_var,
                width=400,
                fg_color=COLORS['bg_secondary'],
                placeholder_text=self.lang.get('ai_keywords_example')
            )
            keywords_entry.pack(padx=15, pady=5)
            
            # Test button
            def test_api():
                api_key = api_key_var.get()
                if not api_key:
                    messagebox.showwarning(self.lang.get('warning'), self.lang.get('ai_recommender_api_key_not_set'))
                    return
                
                try:
                    from ai_color_recommender import AIColorRecommender
                    recommender = AIColorRecommender(api_key, lang=self.lang)
                    result = recommender.test_api_key()
                    if result:
                        messagebox.showinfo(self.lang.get('success'), self.lang.get('ai_api_test_success'))
                    else:
                        messagebox.showerror(self.lang.get('error'), self.lang.get('ai_api_invalid_key'))
                except Exception as e:
                    messagebox.showerror(self.lang.get('error'), self.lang.get('ai_api_test_failed').format(error=str(e)))
            
            ModernSecondaryButton(content, text=self.lang.get('ai_test_api'), command=test_api, width=150).pack(anchor='w', padx=15, pady=15)
            
            # Buttons
            btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            btn_frame.pack(fill='x', padx=15, pady=15)
            
            def save_settings():
                new_settings = {
                    'api_key': api_key_var.get(),
                    'num_colors': int(num_colors_var.get()),
                    'keywords': keywords_var.get()
                }
                AISettings.save_settings(self.file_handler, new_settings)
                self.ai_recommender = None  # Reset recommender
                self.log_action("AI settings saved")
                dialog.destroy()
            
            ModernButton(btn_frame, text=self.lang.get('button_save'), command=save_settings, width=100).pack(side='left', padx=5)
            ModernSecondaryButton(btn_frame, text=self.lang.get('button_cancel'), command=dialog.destroy, width=100).pack(side='left', padx=5)
            
        except ImportError:
            messagebox.showerror(self.lang.get('error'), self.lang.get('ai_module_missing'))
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('ai_settings_open_failed').format(error=str(e)))

    def open_preset_palettes(self):
        """Open preset palettes browser"""
        try:
            from preset_generator import PresetPaletteGenerator
            
            dialog = ctk.CTkToplevel(self)
            set_window_icon(dialog)
            dialog.title(self.lang.get('dialog_preset_palettes'))
            dialog.geometry("800x600")
            dialog.transient(self)
            dialog.grab_set()
            dialog.configure(fg_color=COLORS['bg_dark'])
            
            # Load preset palettes using FileHandler
            presets = []
            try:
                presets = PresetPaletteGenerator.load_palettes(self.file_handler, 'preset_palettes.dat')
            except Exception:
                presets = []
            
            # If no presets found, try generating
            if not presets:
                try:
                    generator = PresetPaletteGenerator()
                    presets = generator.generate_all_palettes(count=100)
                    generator.save_palettes(self.file_handler, 'preset_palettes.dat')
                except Exception:
                    presets = []
            
            # Header
            header = ctk.CTkFrame(dialog, fg_color=COLORS['bg_secondary'], height=60)
            header.pack(fill='x')
            header.pack_propagate(False)
            
            ctk.CTkLabel(
                header,
                text=f" {self.lang.get('preset_palettes')}",
                image=self._get_icon('palette'),
                compound='left',
                font=ctk.CTkFont(family=FONT_FAMILY, size=16, weight="bold"),
                text_color=COLORS['text_primary']
            ).pack(side='left', padx=15, pady=15)
            
            # Filter section
            filter_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            filter_frame.pack(fill='x', padx=15, pady=10)
            
            ctk.CTkLabel(
                filter_frame,
                text=self.lang.get('preset_filter'),
                font=ctk.CTkFont(family=FONT_FAMILY, size=12),
                text_color=COLORS['text_primary']
            ).pack(side='left')
            
            # Get unique tags
            all_tags = set()
            for p in presets:
                tags = p.get('tags', [])
                if isinstance(tags, list):
                    all_tags.update(tags)
            
            tag_list = [self.lang.get('preset_all')] + sorted(list(all_tags))
            
            filter_var = ctk.StringVar(value=self.lang.get('preset_all'))
            filter_combo = ctk.CTkComboBox(
                filter_frame,
                values=tag_list,
                variable=filter_var,
                fg_color=COLORS['bg_card'],
                button_color=COLORS['accent'],
                width=150
            )
            filter_combo.pack(side='left', padx=10)
            
            # Count label
            count_label = ctk.CTkLabel(
                filter_frame,
                text=self.lang.get('preset_count').format(current=len(presets), total=len(presets)),
                font=ctk.CTkFont(family=FONT_FAMILY, size=11),
                text_color=COLORS['text_secondary']
            )
            count_label.pack(side='right')
            
            # Palette grid
            palette_scroll = ctk.CTkScrollableFrame(dialog, fg_color=COLORS['bg_card'])
            palette_scroll.pack(fill='both', expand=True, padx=15, pady=10)
            
            displayed_palettes = []
            
            def display_palettes(filter_tag=None):
                nonlocal displayed_palettes
                
                for widget in palette_scroll.winfo_children():
                    widget.destroy()
                
                if filter_tag and filter_tag != self.lang.get('preset_all'):
                    displayed_palettes = [p for p in presets if filter_tag in p.get('tags', [])]
                else:
                    displayed_palettes = presets
                
                count_label.configure(
                    text=self.lang.get('preset_count').format(current=len(displayed_palettes), total=len(presets))
                )
                
                for i, preset in enumerate(displayed_palettes[:100]):  # Limit display for performance
                    palette_card = ctk.CTkFrame(
                        palette_scroll,
                        fg_color=COLORS['bg_secondary'],
                        corner_radius=8
                    )
                    palette_card.pack(fill='x', pady=4, padx=5)
                    
                    # Name and tags
                    info_frame = ctk.CTkFrame(palette_card, fg_color="transparent")
                    info_frame.pack(fill='x', padx=10, pady=(8, 5))
                    
                    name = preset.get('name', f'Preset {i+1}')
                    ctk.CTkLabel(
                        info_frame,
                        text=name,
                        font=ctk.CTkFont(family=FONT_FAMILY, size=11, weight="bold"),
                        text_color=COLORS['text_primary']
                    ).pack(side='left')
                    
                    tags = preset.get('tags', [])
                    if tags:
                        ctk.CTkLabel(
                            info_frame,
                            text=self.lang.get('preset_tags_format').format(tags=', '.join(tags[:3])),
                            font=ctk.CTkFont(family=FONT_FAMILY, size=9),
                            text_color=COLORS['text_muted']
                        ).pack(side='right')
                    
                    # Color bar with Canvas for variable width ratio
                    colors = preset.get('colors', [])
                    if colors:
                        bar_container = ctk.CTkFrame(palette_card, height=30, fg_color="transparent")
                        bar_container.pack(fill='x', padx=10, pady=(0, 5))
                        bar_container.pack_propagate(False)
                        
                        display_colors = colors[:10]
                        
                        # Use Canvas for precise width calculation
                        canvas = tk.Canvas(
                            bar_container,
                            height=30,
                            bg=COLORS['bg_secondary'],
                            highlightthickness=0
                        )
                        canvas.pack(fill='both', expand=True)
                        
                        # Draw palette bar with variable width ratio
                        def draw_preset_bar(c=canvas, cols=display_colors):
                            c.delete('all')
                            c.update_idletasks()
                            canvas_width = c.winfo_width()
                            if canvas_width <= 1:
                                canvas_width = 700
                            
                            box_width = float(canvas_width) / float(len(cols))
                            for idx, color in enumerate(cols):
                                x1 = int(idx * box_width)
                                x2 = int((idx + 1) * box_width)
                                c.create_rectangle(x1, 0, x2, 30, fill=color, outline='')
                        
                        canvas.after(50, lambda: draw_preset_bar(canvas, display_colors))
                    
                    # Use button
                    def make_use(p):
                        def use_preset():
                            colors = p.get('colors', [])
                            name = p.get('name', 'Preset')
                            if colors:
                                new_entry = {'name': name, 'colors': colors.copy()}
                                self.saved_palettes.append(new_entry)
                                self._saved_selected = len(self.saved_palettes) - 1
                                self.render_saved_list()
                                self.mark_modified()
                                messagebox.showinfo(
                                    self.lang.get('preset_added_title'),
                                    self.lang.get('preset_added_msg').format(name=name)
                                )
                                self.log_action(f"Added preset palette: {name}")
                        return use_preset
                    
                    use_btn = ModernSecondaryButton(
                        palette_card,
                        text=self.lang.get('preset_use'),
                        command=make_use(preset),
                        width=60,
                        height=28
                    )
                    use_btn.pack(side='right', padx=10, pady=8)
            
            def on_filter_change(*args):
                display_palettes(filter_var.get())
            
            filter_var.trace_add('write', on_filter_change)
            
            display_palettes()
            
            # Close button
            ModernSecondaryButton(dialog, text=self.lang.get('close_btn'), command=dialog.destroy, width=100).pack(pady=15)
            
        except ImportError:
            messagebox.showerror(self.lang.get('error'), self.lang.get('preset_module_missing'))
        except Exception as e:
            messagebox.showerror(self.lang.get('error'), self.lang.get('preset_open_failed').format(error=str(e)))

    def _show_palette_selection_dialog(self, metadata):
        """Show palette selection dialog for loading palettes"""
        dialog = ctk.CTkToplevel(self)
        set_window_icon(dialog)
        dialog.title(self.lang.get('dialog_open_mps'))
        dialog.geometry("500x400")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(fg_color=COLORS['bg_dark'])
        
        # Header
        ctk.CTkLabel(
            dialog,
            text=self.lang.get('saved_palettes_list'),
            font=ctk.CTkFont(family=FONT_FAMILY, size=14, weight="bold"),
            text_color=COLORS['text_primary']
        ).pack(anchor='w', padx=15, pady=15)
        
        # Palette list
        list_frame = ctk.CTkScrollableFrame(dialog, fg_color=COLORS['bg_card'])
        list_frame.pack(fill='both', expand=True, padx=15, pady=5)
        
        selected_file = [None]
        
        for item in metadata:
            name = item.get('name', 'Unknown')
            filepath = item.get('filepath', '')
            colors = item.get('colors', [])
            
            palette_btn = ctk.CTkFrame(list_frame, fg_color=COLORS['bg_secondary'], corner_radius=6)
            palette_btn.pack(fill='x', pady=3)
            
            # Name
            ctk.CTkLabel(
                palette_btn,
                text=name,
                font=ctk.CTkFont(family=FONT_FAMILY, size=11, weight="bold"),
                text_color=COLORS['text_primary']
            ).pack(anchor='w', padx=10, pady=(8, 2))
            
            # Color preview
            if colors:
                bar = ctk.CTkFrame(palette_btn, height=20, fg_color="transparent")
                bar.pack(fill='x', padx=10, pady=(0, 8))
                bar.pack_propagate(False)
                
                for c in colors[:8]:
                    swatch = ctk.CTkFrame(bar, fg_color=c, corner_radius=3)
                    swatch.pack(side='left', fill='both', expand=True, padx=1)
            
            # Click to select
            def make_select(fp):
                def handler(e=None):
                    selected_file[0] = fp
                    load_selected()
                return handler
            
            palette_btn.bind('<Button-1>', make_select(filepath))
            palette_btn.configure(cursor='hand2')
        
        def load_selected():
            if selected_file[0]:
                try:
                    self._load_palette_from_file(selected_file[0])
                    dialog.destroy()
                except Exception as e:
                    messagebox.showerror(self.lang.get('error'), str(e))
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill='x', padx=15, pady=15)
        
        def browse_file():
            dialog.destroy()
            filename = filedialog.askopenfilename(
                title=self.lang.get('dialog_open_mps'),
                filetypes=[(self.lang.get('my_palette_file'), '*.mps'), (self.lang.get('all_files'), '*.*')]
            )
            if filename:
                self._load_palette_from_file(filename)
        
        ModernSecondaryButton(btn_frame, text=self.lang.get('browse_other_file'), command=browse_file, width=150).pack(side='left', padx=5)
        ModernSecondaryButton(btn_frame, text=self.lang.get('button_cancel'), command=dialog.destroy, width=100).pack(side='right', padx=5)


if __name__ == "__main__":
    app = PaletteApp()
    app.mainloop()
</file>

<file path="preset_generator.py">
"""
Preset Palette Generator
Generate and manage predefined color palettes
"""

import random


class PresetPaletteGenerator:
    """Pre-defined palette generator"""
    
    # Color schemes from popular design systems
    MATERIAL_DESIGN_COLORS = {
        'Red': ['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'],
        'Pink': ['#FCE4EC', '#F8BBD0', '#F48FB1', '#F06292', '#EC407A', '#E91E63', '#D81B60', '#C2185B', '#AD1457', '#880E4F'],
        'Purple': ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'],
        'Deep Purple': ['#EDE7F6', '#D1C4E9', '#B39DDB', '#9575CD', '#7E57C2', '#673AB7', '#5E35B1', '#512DA8', '#4527A0', '#311B92'],
        'Indigo': ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'],
        'Blue': ['#E3F2FD', '#BBDEFB', '#90CAF9', '#64B5F6', '#42A5F5', '#2196F3', '#1E88E5', '#1976D2', '#1565C0', '#0D47A1'],
        'Light Blue': ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'],
        'Cyan': ['#E0F7FA', '#B2EBF2', '#80DEEA', '#4DD0E1', '#26C6DA', '#00BCD4', '#00ACC1', '#0097A7', '#00838F', '#006064'],
        'Teal': ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'],
        'Green': ['#E8F5E9', '#C8E6C9', '#A5D6A7', '#81C784', '#66BB6A', '#4CAF50', '#43A047', '#388E3C', '#2E7D32', '#1B5E20'],
        'Light Green': ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'],
        'Lime': ['#F9FBE7', '#F0F4C3', '#E6EE9C', '#DCE775', '#D4E157', '#CDDC39', '#C0CA33', '#AFB42B', '#9E9D24', '#827717'],
        'Yellow': ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'],
        'Amber': ['#FFF8E1', '#FFECB3', '#FFE082', '#FFD54F', '#FFCA28', '#FFC107', '#FFB300', '#FFA000', '#FF8F00', '#FF6F00'],
        'Orange': ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100'],
        'Deep Orange': ['#FBE9E7', '#FFCCBC', '#FFAB91', '#FF8A65', '#FF7043', '#FF5722', '#F4511E', '#E64A19', '#D84315', '#BF360C'],
        'Brown': ['#EFEBE9', '#D7CCC8', '#BCAAA4', '#A1887F', '#8D6E63', '#795548', '#6D4C41', '#5D4037', '#4E342E', '#3E2723'],
        'Grey': ['#FAFAFA', '#F5F5F5', '#EEEEEE', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575', '#616161', '#424242', '#212121'],
        'Blue Grey': ['#ECEFF1', '#CFD8DC', '#B0BEC5', '#90A4AE', '#78909C', '#607D8B', '#546E7A', '#455A64', '#37474F', '#263238']
    }
    
    FLAT_UI_COLORS = {
        'Turquoise': '#1ABC9C',
        'Green Sea': '#16A085',
        'Emerald': '#2ECC71',
        'Nephritis': '#27AE60',
        'Peter River': '#3498DB',
        'Belize Hole': '#2980B9',
        'Amethyst': '#9B59B6',
        'Wisteria': '#8E44AD',
        'Wet Asphalt': '#34495E',
        'Midnight Blue': '#2C3E50',
        'Sun Flower': '#F1C40F',
        'Orange': '#F39C12',
        'Carrot': '#E67E22',
        'Pumpkin': '#D35400',
        'Alizarin': '#E74C3C',
        'Pomegranate': '#C0392B',
        'Clouds': '#ECF0F1',
        'Silver': '#BDC3C7',
        'Concrete': '#95A5A6',
        'Asbestos': '#7F8C8D'
    }
    
    SEASONAL_THEMES = {
        'Spring': ['#FFB6C1', '#98FB98', '#87CEEB', '#FFFFE0', '#FFE4E1'],
        'Summer': ['#FFD700', '#FF6347', '#00CED1', '#FF69B4', '#FFA500'],
        'Autumn': ['#D2691E', '#FF8C00', '#8B4513', '#CD853F', '#DEB887'],
        'Winter': ['#4682B4', '#B0C4DE', '#708090', '#FFFFFF', '#ADD8E6']
    }
    
    PURPOSE_THEMES = {
        'Corporate': ['#003366', '#0066CC', '#6699CC', '#99CCFF', '#CCDDFF'],
        'Tech': ['#00D9FF', '#0099CC', '#003D5C', '#FF6600', '#333333'],
        'Nature': ['#228B22', '#32CD32', '#90EE90', '#8FBC8F', '#556B2F'],
        'Elegant': ['#2C3E50', '#8E44AD', '#C0392B', '#E67E22', '#ECF0F1'],
        'Vibrant': ['#FF1744', '#FF9100', '#FFD600', '#00E676', '#00B0FF'],
        'Pastel': ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF'],
        'Dark': ['#121212', '#1E1E1E', '#2C2C2C', '#383838', '#4A4A4A'],
        'Monochrome': ['#000000', '#404040', '#808080', '#BFBFBF', '#FFFFFF'],
        'Warm': ['#FF6B6B', '#FFA07A', '#FFD93D', '#FF8C42', '#F95959'],
        'Cool': ['#4A90E2', '#50C9CE', '#7B68EE', '#5F9EA0', '#6495ED']
    }
    
    def __init__(self):
        self.palettes = []
    
    def hex_to_rgb(self, hex_color):
        """Convert HEX to RGB"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    def rgb_to_hex(self, rgb):
        """Convert RGB to HEX"""
        return '#{:02x}{:02x}{:02x}'.format(*rgb)
    
    def generate_analogous_palette(self, base_hex):
        """Generate analogous color palette"""
        import colorsys
        r, g, b = self.hex_to_rgb(base_hex)
        h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
        
        colors = []
        for offset in [-60, -30, 0, 30, 60]:
            new_h = (h + offset/360) % 1.0
            new_rgb = colorsys.hsv_to_rgb(new_h, s, v)
            new_rgb = tuple(int(x * 255) for x in new_rgb)
            colors.append(self.rgb_to_hex(new_rgb))
        return colors
    
    def generate_complementary_palette(self, base_hex):
        """Generate complementary palette"""
        import colorsys
        r, g, b = self.hex_to_rgb(base_hex)
        h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
        
        # Base color and its complement
        comp_h = (h + 0.5) % 1.0
        comp_rgb = colorsys.hsv_to_rgb(comp_h, s, v)
        comp_rgb = tuple(int(x * 255) for x in comp_rgb)
        
        # Add variations
        colors = [base_hex]
        for v_offset in [0.3, 0.15, 0, -0.15]:
            new_v = max(0, min(1, v + v_offset))
            rgb = colorsys.hsv_to_rgb(comp_h, s, new_v)
            rgb = tuple(int(x * 255) for x in rgb)
            colors.append(self.rgb_to_hex(rgb))
        return colors
    
    def generate_triadic_palette(self, base_hex):
        """Generate triadic palette"""
        import colorsys
        r, g, b = self.hex_to_rgb(base_hex)
        h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
        
        colors = [base_hex]
        for offset in [1/3, 2/3]:
            new_h = (h + offset) % 1.0
            for v_mult in [1.0, 0.7]:
                new_v = v * v_mult
                rgb = colorsys.hsv_to_rgb(new_h, s, new_v)
                rgb = tuple(int(x * 255) for x in rgb)
                colors.append(self.rgb_to_hex(rgb))
        return colors[:5]
    
    def generate_all_palettes(self, count=500):
        """Generate comprehensive palette collection"""
        palettes = []
        palette_id = 1
        
        # 1. Material Design palettes
        for color_name, shades in self.MATERIAL_DESIGN_COLORS.items():
            for i in range(0, len(shades)-4, 2):
                palette = {
                    'id': palette_id,
                    'name': f'Material {color_name} {i+1}',
                    'colors': shades[i:i+5],
                    'tags': ['Material Design', color_name, 'Modern']
                }
                palettes.append(palette)
                palette_id += 1
        
        # 2. Flat UI variations
        flat_colors = list(self.FLAT_UI_COLORS.values())
        for i in range(0, len(flat_colors), 5):
            if i + 5 <= len(flat_colors):
                palette = {
                    'id': palette_id,
                    'name': f'Flat UI {i//5 + 1}',
                    'colors': flat_colors[i:i+5],
                    'tags': ['Flat UI', 'Web', 'Modern']
                }
                palettes.append(palette)
                palette_id += 1
        
        # 3. Generate from flat colors (analogous)
        for color_name, base_color in list(self.FLAT_UI_COLORS.items())[:10]:
            colors = self.generate_analogous_palette(base_color)
            palette = {
                'id': palette_id,
                'name': f'{color_name} Analogous',
                'colors': colors,
                'tags': ['Flat UI', 'Analogous', 'Harmony']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 4. Seasonal themes
        for season, colors in self.SEASONAL_THEMES.items():
            palette = {
                'id': palette_id,
                'name': f'{season} Theme',
                'colors': colors,
                'tags': ['Seasonal', season, 'Theme']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 5. Purpose themes
        for purpose, colors in self.PURPOSE_THEMES.items():
            palette = {
                'id': palette_id,
                'name': f'{purpose} Palette',
                'colors': colors,
                'tags': ['Purpose', purpose, 'Professional']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 6. Generate random combinations
        all_material_colors = []
        for shades in self.MATERIAL_DESIGN_COLORS.values():
            all_material_colors.extend(shades)
        
        themes = ['Gradient', 'Vibrant', 'Soft', 'Bold', 'Muted', 'Bright']
        for i in range(min(count - len(palettes), 300)):
            colors = random.sample(all_material_colors, 5)
            theme = random.choice(themes)
            palette = {
                'id': palette_id,
                'name': f'{theme} Mix {i+1}',
                'colors': colors,
                'tags': ['Generated', theme, 'Random']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 7. Complementary palettes from Material colors
        for color_name, shades in list(self.MATERIAL_DESIGN_COLORS.items())[:8]:
            base = shades[5] if len(shades) > 5 else shades[0]
            colors = self.generate_complementary_palette(base)
            palette = {
                'id': palette_id,
                'name': f'{color_name} Complementary',
                'colors': colors,
                'tags': ['Material Design', 'Complementary', 'Harmony']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 8. Triadic palettes
        for color_name, shades in list(self.MATERIAL_DESIGN_COLORS.items())[:8]:
            base = shades[5] if len(shades) > 5 else shades[0]
            colors = self.generate_triadic_palette(base)
            palette = {
                'id': palette_id,
                'name': f'{color_name} Triadic',
                'colors': colors,
                'tags': ['Material Design', 'Triadic', 'Harmony']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 9. More Material variations (all colors, all harmonies)
        for color_name, shades in self.MATERIAL_DESIGN_COLORS.items():
            for idx in [0, 3, 6, 9]:
                if idx < len(shades):
                    base = shades[idx]
                    # Analogous
                    colors = self.generate_analogous_palette(base)
                    palette = {
                        'id': palette_id,
                        'name': f'{color_name} {idx} Analogous',
                        'colors': colors,
                        'tags': ['Material Design', 'Analogous', color_name]
                    }
                    palettes.append(palette)
                    palette_id += 1
                    
                    # Complementary
                    colors = self.generate_complementary_palette(base)
                    palette = {
                        'id': palette_id,
                        'name': f'{color_name} {idx} Complement',
                        'colors': colors,
                        'tags': ['Material Design', 'Complementary', color_name]
                    }
                    palettes.append(palette)
                    palette_id += 1
        
        # 10. Flat UI + Material Design mixes
        flat_list = list(self.FLAT_UI_COLORS.values())
        for i in range(30):
            material_colors = random.sample(all_material_colors, 3)
            flat_colors = random.sample(flat_list, 2)
            colors = material_colors + flat_colors
            random.shuffle(colors)
            palette = {
                'id': palette_id,
                'name': f'Material+Flat Mix {i+1}',
                'colors': colors,
                'tags': ['Mixed', 'Material Design', 'Flat UI']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 11. More theme variations
        theme_mixes = [
            ('Warm Sunset', ['#FF6B6B', '#FFA07A', '#FFD93D', '#FF8C42', '#F95959']),
            ('Cool Ocean', ['#4A90E2', '#50C9CE', '#6FEDD6', '#5DADE2', '#3498DB']),
            ('Forest Green', ['#2ECC71', '#27AE60', '#1E8449', '#0B5345', '#229954']),
            ('Royal Purple', ['#9B59B6', '#8E44AD', '#6C3483', '#512E5F', '#7D3C98']),
            ('Warm Earth', ['#A0522D', '#8B4513', '#D2691E', '#CD853F', '#DEB887']),
            ('Neon Night', ['#FF00FF', '#00FFFF', '#FFFF00', '#FF1493', '#00FF00']),
            ('Pastel Dream', ['#FFB3BA', '#BAFFC9', '#BAE1FF', '#FFFFBA', '#E0BBE4']),
            ('Corporate Blue', ['#003366', '#004D99', '#0066CC', '#0080FF', '#3399FF']),
            ('Vintage Rose', ['#C88B8B', '#D4A5A5', '#E8C4C4', '#F5E1E1', '#FFEEE6']),
            ('Cyber Tech', ['#00FF9F', '#00FFFF', '#BF00FF', '#FF00BF', '#FFBF00']),
            ('Desert Sand', ['#EDC9AF', '#E0AC69', '#C19A6B', '#D2B48C', '#F5DEB3']),
            ('Arctic Ice', ['#E0F2F7', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6']),
            ('Cherry Blossom', ['#FFB7C5', '#FFC0CB', '#FFD1DC', '#FFE4E1', '#FFF0F5']),
            ('Mint Fresh', ['#98FF98', '#90EE90', '#8FBC8F', '#3CB371', '#2E8B57']),
            ('Autumn Leaves', ['#FF6347', '#FF7F50', '#FF8C00', '#FFA500', '#FFB347']),
        ]
        
        for theme_name, colors in theme_mixes:
            palette = {
                'id': palette_id,
                'name': theme_name,
                'colors': colors,
                'tags': ['Theme', 'Curated', theme_name.split()[0]]
            }
            palettes.append(palette)
            palette_id += 1
        
        # 12. Monochromatic variations
        base_colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                       '#FF8800', '#8800FF', '#00FF88', '#FF0088', '#88FF00', '#0088FF']
        for base_hex in base_colors:
            import colorsys
            r, g, b = self.hex_to_rgb(base_hex)
            h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
            colors = []
            for v_val in [0.3, 0.5, 0.7, 0.85, 1.0]:
                rgb = colorsys.hsv_to_rgb(h, s, v_val)
                rgb = tuple(int(x * 255) for x in rgb)
                colors.append(self.rgb_to_hex(rgb))
            palette = {
                'id': palette_id,
                'name': f'Mono {base_hex[1:4]}',
                'colors': colors,
                'tags': ['Monochromatic', 'Gradient', 'Simple']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 13. Extended Material Design combinations
        material_keys = list(self.MATERIAL_DESIGN_COLORS.keys())
        for i in range(50):
            color1, color2 = random.sample(material_keys, 2)
            shades1 = self.MATERIAL_DESIGN_COLORS[color1]
            shades2 = self.MATERIAL_DESIGN_COLORS[color2]
            colors = [
                random.choice(shades1),
                random.choice(shades1),
                random.choice(shades2),
                random.choice(shades2),
                random.choice(shades1)
            ]
            palette = {
                'id': palette_id,
                'name': f'{color1}+{color2} Blend',
                'colors': colors,
                'tags': ['Material Design', 'Blend', color1, color2]
            }
            palettes.append(palette)
            palette_id += 1
        
        # 14. Saturation variations
        for color_name, shades in list(self.MATERIAL_DESIGN_COLORS.items())[:10]:
            base = shades[5] if len(shades) > 5 else shades[0]
            r, g, b = self.hex_to_rgb(base)
            h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
            colors = []
            for s_val in [0.2, 0.4, 0.6, 0.8, 1.0]:
                rgb = colorsys.hsv_to_rgb(h, s_val, v)
                rgb = tuple(int(x * 255) for x in rgb)
                colors.append(self.rgb_to_hex(rgb))
            palette = {
                'id': palette_id,
                'name': f'{color_name} Saturation',
                'colors': colors,
                'tags': ['Material Design', 'Saturation', color_name]
            }
            palettes.append(palette)
            palette_id += 1
        
        # 15. Temperature-based palettes
        warm_hues = [0, 15, 30, 45]  # Red to yellow range
        cool_hues = [180, 195, 210, 225, 240]  # Cyan to blue range
        
        for i in range(20):
            colors = []
            for hue in random.sample(warm_hues, 3) + random.sample([20, 35], 2):
                h = hue / 360
                s = random.uniform(0.6, 0.9)
                v = random.uniform(0.7, 1.0)
                rgb = colorsys.hsv_to_rgb(h, s, v)
                rgb = tuple(int(x * 255) for x in rgb)
                colors.append(self.rgb_to_hex(rgb))
            palette = {
                'id': palette_id,
                'name': f'Warm Palette {i+1}',
                'colors': colors,
                'tags': ['Temperature', 'Warm', 'Generated']
            }
            palettes.append(palette)
            palette_id += 1
        
        for i in range(20):
            colors = []
            for hue in random.sample(cool_hues, 5):
                h = hue / 360
                s = random.uniform(0.6, 0.9)
                v = random.uniform(0.7, 1.0)
                rgb = colorsys.hsv_to_rgb(h, s, v)
                rgb = tuple(int(x * 255) for x in rgb)
                colors.append(self.rgb_to_hex(rgb))
            palette = {
                'id': palette_id,
                'name': f'Cool Palette {i+1}',
                'colors': colors,
                'tags': ['Temperature', 'Cool', 'Generated']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 16. Brand-inspired palettes
        brand_palettes = [
            ('Tech Blue', ['#0078D7', '#106EBE', '#005A9E', '#00428A', '#003E82']),
            ('Social Media', ['#1DA1F2', '#FF0000', '#0077B5', '#833AB4', '#25D366']),
            ('Nature Green', ['#52B788', '#40916C', '#2D6A4F', '#1B4332', '#081C15']),
            ('Sunset Orange', ['#FF6B35', '#F7931E', '#FDC500', '#F78F1E', '#F95738']),
            ('Deep Purple', ['#5D3FD3', '#6A5ACD', '#7B68EE', '#9370DB', '#8A2BE2']),
            ('Coral Pink', ['#FF6F61', '#FF7F7F', '#FF91A4', '#FFA6C1', '#FFB6C1']),
            ('Emerald', ['#50C878', '#3EB489', '#2D9D7A', '#1B866B', '#0A6F5C']),
            ('Amber', ['#FFBF00', '#FFB700', '#FFAA00', '#FF9500', '#FF8800']),
            ('Teal', ['#008080', '#00A9A5', '#00B4A6', '#00C4AD', '#00D4B4']),
            ('Crimson', ['#DC143C', '#C91A3A', '#B21838', '#9B1436', '#841134']),
            ('Navy', ['#000080', '#001A66', '#003080', '#004799', '#005EB3']),
            ('Gold', ['#FFD700', '#FFC700', '#FFB700', '#FFA700', '#FF9700']),
            ('Silver', ['#C0C0C0', '#A9A9A9', '#999999', '#808080', '#696969']),
            ('Olive', ['#808000', '#999900', '#AAAA00', '#BBBB00', '#CCCC00']),
            ('Maroon', ['#800000', '#990000', '#AA0000', '#BB0000', '#CC0000']),
            ('Lime', ['#00FF00', '#33FF33', '#66FF66', '#99FF99', '#CCFFCC']),
            ('Aqua', ['#00FFFF', '#33FFFF', '#66FFFF', '#99FFFF', '#CCFFFF']),
            ('Fuchsia', ['#FF00FF', '#FF33FF', '#FF66FF', '#FF99FF', '#FFCCFF']),
            ('Indigo', ['#4B0082', '#5D1A99', '#6F33B3', '#814DCC', '#9366E6']),
            ('Turquoise', ['#40E0D0', '#4DE6D7', '#5AECDE', '#66F2E5', '#73F8EC']),
        ]
        
        for name, colors in brand_palettes:
            palette = {
                'id': palette_id,
                'name': name,
                'colors': colors,
                'tags': ['Brand', 'Curated', name.split()[0]]
            }
            palettes.append(palette)
            palette_id += 1
        
        # 17. Split complementary palettes
        for color_name, shades in list(self.MATERIAL_DESIGN_COLORS.items())[:15]:
            base = shades[5] if len(shades) > 5 else shades[0]
            r, g, b = self.hex_to_rgb(base)
            h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
            
            colors = [base]
            # Split complementary (150¬∞ and 210¬∞ from base)
            for angle in [150, 210]:
                new_h = (h + angle/360) % 1.0
                for v_mult in [1.0, 0.7]:
                    new_v = v * v_mult
                    rgb = colorsys.hsv_to_rgb(new_h, s, new_v)
                    rgb = tuple(int(x * 255) for x in rgb)
                    colors.append(self.rgb_to_hex(rgb))
            
            palette = {
                'id': palette_id,
                'name': f'{color_name} Split Comp',
                'colors': colors[:5],
                'tags': ['Material Design', 'Split Complementary', color_name]
            }
            palettes.append(palette)
            palette_id += 1
        
        # 18. Square (tetradic) palettes
        for color_name, shades in list(self.MATERIAL_DESIGN_COLORS.items())[:15]:
            base = shades[5] if len(shades) > 5 else shades[0]
            r, g, b = self.hex_to_rgb(base)
            h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
            
            colors = [base]
            # Square: 90¬∞, 180¬∞, 270¬∞ from base
            for angle in [90, 180, 270]:
                new_h = (h + angle/360) % 1.0
                rgb = colorsys.hsv_to_rgb(new_h, s, v)
                rgb = tuple(int(x * 255) for x in rgb)
                colors.append(self.rgb_to_hex(rgb))
            
            palette = {
                'id': palette_id,
                'name': f'{color_name} Square',
                'colors': colors[:5],
                'tags': ['Material Design', 'Square', 'Tetradic']
            }
            palettes.append(palette)
            palette_id += 1
        
        # 19. More curated theme palettes
        extra_themes = [
            ('Midnight Blue', ['#191970', '#000080', '#00008B', '#0000CD', '#0000FF']),
            ('Peachy Keen', ['#FFDAB9', '#FFDEAD', '#FFE4B5', '#FFEFD5', '#FFF8DC']),
            ('Lavender Fields', ['#E6E6FA', '#D8BFD8', '#DDA0DD', '#EE82EE', '#DA70D6']),
            ('Cinnamon Spice', ['#D2691E', '#CD853F', '#DEB887', '#F5DEB3', '#FFEFD5']),
            ('Seafoam', ['#9FE2BF', '#87CEEB', '#7FFFD4', '#40E0D0', '#48D1CC']),
            ('Burgundy Wine', ['#800020', '#8B0000', '#A52A2A', '#B22222', '#CD5C5C']),
            ('Mustard Yellow', ['#FFDB58', '#FFD700', '#FFDF00', '#FFE135', '#FFEC8B']),
            ('Plum Purple', ['#8E4585', '#9932CC', '#8B008B', '#9400D3', '#9370DB']),
            ('Sage Green', ['#BCB88A', '#C9CC3F', '#B2AC88', '#A7A77D', '#9C9C72']),
            ('Rust', ['#B7410E', '#C85A17', '#D97220', '#EA8A29', '#FBA232']),
            ('Charcoal', ['#36454F', '#464646', '#555555', '#696969', '#808080']),
            ('Cream', ['#FFFDD0', '#FAFAD2', '#FFF8DC', '#FFEFD5', '#FFE4B5']),
            ('Slate', ['#708090', '#778899', '#87CEEB', '#B0C4DE', '#DCDCDC']),
            ('Tangerine', ['#FF9F00', '#FFA500', '#FFB347', '#FFC87C', '#FFDAB9']),
            ('Raspberry', ['#E30B5C', '#E6004C', '#E6007E', '#E600AC', '#E63E97']),
            ('Pine', ['#01796F', '#0B7B70', '#147D71', '#1E7F72', '#288173']),
            ('Champagne', ['#F7E7CE', '#F8E8D0', '#F9E9D2', '#FAEAD4', '#FBEBD6']),
            ('Mahogany', ['#C04000', '#C85A3C', '#D07456', '#D88E70', '#E0A88A']),
            ('Periwinkle', ['#CCCCFF', '#C5CBE1', '#BFC9E3', '#B9C8E5', '#B3C6E7']),
            ('Butterscotch', ['#E1A95F', '#E5B56C', '#E9C179', '#EDCD86', '#F1D993']),
        ]
        
        for name, colors in extra_themes:
            palette = {
                'id': palette_id,
                'name': name,
                'colors': colors,
                'tags': ['Theme', 'Curated', name.split()[0]]
            }
            palettes.append(palette)
            palette_id += 1
        
        # 20. Final random high-quality mixes
        for i in range(100):
            colors = random.sample(all_material_colors, 5)
            palette = {
                'id': palette_id,
                'name': f'Curated Mix {i+1}',
                'colors': colors,
                'tags': ['Generated', 'Mixed', 'Quality']
            }
            palettes.append(palette)
            palette_id += 1
        
        self.palettes = palettes
        return palettes
    
    def save_palettes(self, file_handler, filename='preset_palettes.dat'):
        """Save palettes using file_handler encryption"""
        try:
            data = {
                'palettes': self.palettes,
                'count': len(self.palettes)
            }
            
            success = file_handler.save_data_file(filename, data, data_dir='data')
            
            if success:
                print(f"‚úì Saved {len(self.palettes)} palettes to data/{filename}")
                print(f"‚úì Using file_handler encryption")
            return success
        except Exception as e:
            print(f"Error saving palettes: {e}")
            return False
    
    @staticmethod
    def load_palettes(file_handler, filename='preset_palettes.dat'):
        """Load palettes using file_handler decryption"""
        try:
            data = file_handler.load_data_file(filename, data_dir='data', default=None)
            
            if data is None:
                print(f"No palette file found: data/{filename}")
                return []
            
            palettes = data.get('palettes', [])
            print(f"‚úì Loaded {len(palettes)} palettes from data/{filename}")
            return palettes
        except Exception as e:
            print(f"Error loading palettes: {e}")
            return []


# Generate palettes if run directly
if __name__ == "__main__":
    from file_handler import FileHandler
    
    file_handler = FileHandler()
    generator = PresetPaletteGenerator()
    palettes = generator.generate_all_palettes(count=1200)
    print(f"Generated {len(palettes)} palettes")
    
    # Save to data folder using file_handler
    generator.save_palettes(file_handler, 'preset_palettes.dat')
    
    # Test loading
    loaded = PresetPaletteGenerator.load_palettes(file_handler, 'preset_palettes.dat')
    print(f"Verification: Loaded {len(loaded)} palettes")
</file>

<file path="README.md">
<div align="center">

# üé® Color Palette Generator

**Your Professional Color Palette Creation Suite**

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Python 3.10+](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/)
[![Windows](https://img.shields.io/badge/platform-Windows%2010%2F11-blue.svg)](https://www.microsoft.com/windows)

*Create, manage, and export beautiful color palettes with AI-powered intelligence and professional tools.*

[Features](#-features) ‚Ä¢ [Installation](#-installation) ‚Ä¢ [Usage](#-usage) ‚Ä¢ [Building](#-building)

---

</div>

## üéØ What is Color Palette Generator?

Color Palette Generator is a **powerful, feature-rich desktop application** for creating and managing color palettes with professional-grade tools. Extract colors from images, generate harmonious schemes based on color theory, or let AI create palettes from your descriptions.

Perfect for:
- üé® **Designers & Artists** crafting cohesive color schemes
- üíº **Brand Strategists** developing visual identities
- üñ•Ô∏è **Developers** needing consistent UI color systems
- üì∏ **Photographers** extracting dominant image colors

## ‚ú® Features

- **10+ Color Harmony Schemes**: Complementary, Analogous, Triadic, and more
- **AI-Powered Generation**: Google Gemini integration for creative palettes
- **Image Color Extraction**: K-means clustering for dominant colors
- **Custom Harmony Editor**: Create your own color rules with HSV offsets
- **Smart Palette Management**: Track, preview, and organize all your palettes
- **Multiple Export Formats**: PNG, TXT, and encrypted MPS files
- **Multi-Language**: Full Korean/English support
- **Modern UI**: CustomTkinter dark mode interface

## üì¶ Installation

Download ColorPaletteGenerator.exe from [Releases](../../releases) or run from source:

```powershell
pip install -r requirements.txt
python main.py
```

## üöÄ Quick Start

1. Launch the application
2. Choose input method (HEX, Color Picker, or Image)
3. Select harmony type
4. Click **Generate Palette**
5. Save, export, or recolor images!

## üèóÔ∏è Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       UI Layer (CustomTkinter)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    Generator Layer (Color Logic)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Services Layer (AI, Image, Export)    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Storage Layer (Encrypted)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîí Security

- **Fernet Encryption**: All data files encrypted with AES-128
- **External Key**: Machine-specific secret.key (gitignored)
- **API Protection**: Gemini API keys never stored in plaintext

## üìú License

MIT License - see [LICENSE](LICENSE) for details.

---

<div align="center">

**Color Palette Generator** - Where Creativity Meets Technology üé®

Made with ‚ù§Ô∏è by jiwonjae-svg

</div>
</file>

<file path=".gitignore">
venv/
.venv/
env/
*.log
build/
dist/
data/
__pycache__/
Temp/
*.spec

# Embedded resources (large binary data)
embedded_icons.py
assets/

# Secret key file (security)
secret.key
</file>

</files>
